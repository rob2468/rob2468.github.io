<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>为 GCDWebServer 引入 WebSocket 支持 | jam.chenjun blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言  借助一些工具库，iOS 设备可以配置成为服务器，在此之上可以做许多有意思的事情。例如，HttpServerDebug 基于这种能力，提供了现场调试 iOS App 的能力。 CocoaHTTPServer 是比较早期的提供服务器能力的库，(基础 Socket 通信能力由 CocoaAsyncSocket 提供，)现在已不再维护。 GCDWebServer 也是一个提供服务器能力的工具，">
<meta property="og:type" content="article">
<meta property="og:title" content="为 GCDWebServer 引入 WebSocket 支持">
<meta property="og:url" content="https://rob2468.github.io/2019/06/15/hsd-websocket/index.html">
<meta property="og:site_name" content="jam.chenjun blog">
<meta property="og:description" content="前言  借助一些工具库，iOS 设备可以配置成为服务器，在此之上可以做许多有意思的事情。例如，HttpServerDebug 基于这种能力，提供了现场调试 iOS App 的能力。 CocoaHTTPServer 是比较早期的提供服务器能力的库，(基础 Socket 通信能力由 CocoaAsyncSocket 提供，)现在已不再维护。 GCDWebServer 也是一个提供服务器能力的工具，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rob2468.github.io/resources/figures/2019-06-15-websocket-retain.png">
<meta property="article:published_time" content="2019-06-15T00:00:00.000Z">
<meta property="article:modified_time" content="2021-08-01T08:45:03.247Z">
<meta property="article:author" content="陈军">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rob2468.github.io/resources/figures/2019-06-15-websocket-retain.png">
  
    <link rel="alternate" href="/atom.xml" title="jam.chenjun blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">jam.chenjun blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rob2468.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-hsd-websocket" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/06/15/hsd-websocket/" class="article-date">
  <time class="dt-published" datetime="2019-06-15T00:00:00.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      为 GCDWebServer 引入 WebSocket 支持
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 class="title"></h1>

<h2 id="section_1">前言</h2>

<p>借助一些工具库，iOS 设备可以配置成为服务器，在此之上可以做许多有意思的事情。例如，<a href="https://github.com/rob2468/HttpServerDebug" target="_blank">HttpServerDebug</a> 基于这种能力，提供了现场调试 iOS App 的能力。</p>
<p><a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank">CocoaHTTPServer</a> 是比较早期的提供服务器能力的库，(基础 Socket 通信能力由 <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank">CocoaAsyncSocket</a> 提供，)现在已不再维护。</p>
<p><a href="https://github.com/swisspol/GCDWebServer" target="_blank">GCDWebServer</a> 也是一个提供服务器能力的工具，基于 GCD 实现，当前仍在维护中。</p>
<p>HSD（HttpServerDebug） 基于 GCDWebServer。HSD 希望能够主动的把信息发送到前端，这依赖于 WebSocket 协议，但是 GCDWebServer 不支持。</p>
<p>HSD 对 GCDWebServer 进行二次开发，增加 WebSocket 能力，并且不再同步原始 GCDWebServer 库。这是支持 WebSocket 协议的一次实践，并没有完备的支持 WebSocket 的所有方面，如新版本的 WebSochet 协议、加密数据传输等。</p>
<h2 id="section_2">Socket 实现</h2>

<p>Http 和 WebSocket 都是应用层的协议，其底层都依赖 Socket 进行通信。</p>
<p>GCDWebServer 中，Socket 的建立使用 POSIX C 函数实现。生成的核心数据对象是一对 Socket 文件描述符，分别代表服务端和客户端。对 Socket 文件描述符的监听、读取、写入均使用 GCD 函数进行了封装。</p>
<h2 id="section_3">WebSocket 协议</h2>

<p>WebSocket 协议是借用 HTTP 101 switch protocol 来完成协议转换，从 HTTP 协议切换成 WebSocket 通信协议。一个典型的建立连接请求和响应头如下，具体含义见参考文献链接。</p>
<div class="code"><pre><code>Request Headers
GET ws://localhost:5555/ HTTP/1.1
Host: localhost:5555
Connection: Upgrade
Pragma: no-cache
Cache-Control: no-cache
Upgrade: websocket
Origin: http://localhost:5555
Sec-WebSocket-Version: 13
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie: locale=zh-cn
Sec-WebSocket-Key: qtAGynUVRNU3JdTH1dsQiA==
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits

<p>Response Headers<br>HTTP/1.1 101 Web Socket Protocol Handshake<br>WebSocket-Location: ws://localhost:5555/<br>Sec-WebSocket-Accept: We1qmJgFvf8w3cDqTuUO5B6lrNA=<br>Upgrade: WebSocket<br>Connection: Upgrade<br>WebSocket-Origin: <a target="_blank" rel="noopener" href="http://localhost:5555/">http://localhost:5555</a><br></code></pre></div></p>
<p>WebSocket 协议传输的数据以 Frame 为单位，每个 Frame 都有严格的数据结构，如下表所示。其中每个位以字节流形式考察，具体含义见参考文献链接。</p>
<div class="code"><pre><code>  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</code></pre></div>

<h2 id="section_4">持有关系</h2>

<p class="post-image">
  <img src="/resources/figures/2019-06-15-websocket-retain.png" alt="Retain Relationship" width="60%">
</p>

<p>如上图所示，增加 WebSocket 协议支持后，对象实例的持有关系有一些变化。GCDWebServer 表示服务器实例，GCDWebServerConnection 表示一次通信连接实例。</p>
<p>GCDWebServer 实例和 GCDWebServerConnection 实例的对应关系是 1 : n，这在修改前后都是一样的。修改前，GCDWebServerConnection 实例没有显式的声明被某个对象持有，其内部实现中，dispatch_read 和 dispatch_write 的 block 持有其自身，并在 block 执行结束后释放。</p>
<p>修改后，明确了 GCDWebServerConnection 实例的持有关系。GCDWebServer 实例接收到请求并实例出 GCDWebServerConnection 对象后，显示持有该对象。</p>
<p>HSDGWebSocket 是新增的负责处理 WebSocket 协议的类。GCDWebServerConnection 检测到当前请求为 WebSocket 请求时，实例出 HSDGWebSocket 对象，并显示持有。他们的对应关系是 1 : 1。</p>
<h2 id="section_5">建立连接</h2>

<div class="code"><pre><code>+ (BOOL)isWebSocketRequest:(NSDictionary *)requestHeaders &#123;
    NSString *connectionHeaderValue = [requestHeaders objectForKey:@"Connection"];
    NSString *upgradeHeaderValue = [requestHeaders objectForKey:@"Upgrade"];

<pre><code>BOOL isWebSocket = YES;
if (!upgradeHeaderValue || !connectionHeaderValue) &#123;
    isWebSocket = NO;
&#125; else if ([upgradeHeaderValue caseInsensitiveCompare:@&quot;WebSocket&quot;] != NSOrderedSame) &#123;
    isWebSocket = NO;
&#125; else if ([connectionHeaderValue rangeOfString:@&quot;Upgrade&quot; options:NSCaseInsensitiveSearch].location == NSNotFound) &#123;
    isWebSocket = NO;
&#125;
return isWebSocket;
</code></pre>
<p>}<br></code></pre></div></p>
<p>如上代码所示，接收到请求后，根据请求头判断是否是 WebSocket 请求。如果是 WekSocket 请求，则发送对应的响应头，如下代码所示。请求和响应的格式和值见 WebSocket 协议的定义。</p>
<div class="code"><pre><code>- (void)sendResponseHeaders &#123;
    // request info
    NSDictionary *requestHeaders = CFBridgingRelease(CFHTTPMessageCopyAllHeaderFields(self.requestMessage));
    NSString *origin = [requestHeaders objectForKey:@"Origin"];
    NSString *host = [requestHeaders objectForKey:@"Host"];
    NSString *secWebSocketKey = [requestHeaders objectForKey:@"Sec-WebSocket-Key"];

<pre><code>NSURL *requestURL = CFBridgingRelease(CFHTTPMessageCopyRequestURL(self.requestMessage));
NSString *relativeString = [requestURL relativeString];

// response
CFHTTPMessageRef responseMessage = CFHTTPMessageCreateResponse(kCFAllocatorDefault, 101, CFSTR(&quot;Web Socket Protocol Handshake&quot;), kCFHTTPVersion1_1);
CFHTTPMessageSetHeaderFieldValue(responseMessage, CFSTR(&quot;Connection&quot;), CFSTR(&quot;Upgrade&quot;));
CFHTTPMessageSetHeaderFieldValue(responseMessage, CFSTR(&quot;Upgrade&quot;), CFSTR(&quot;WebSocket&quot;));

CFHTTPMessageSetHeaderFieldValue(responseMessage, CFSTR(&quot;WebSocket-Origin&quot;), (__bridge CFStringRef)origin);
NSString *locationValue = [NSString stringWithFormat:@&quot;ws://%@%@&quot;, host, relativeString];
CFHTTPMessageSetHeaderFieldValue(responseMessage, CFSTR(&quot;WebSocket-Location&quot;), (__bridge CFStringRef)locationValue);

// Sec-WebSocket-Accept
NSString *guid = @&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;;
NSString *acceptValue = [[secWebSocketKey stringByAppendingString:guid] dataUsingEncoding: NSUTF8StringEncoding].sha1Digest.base64Encoded;
if (acceptValue.length &gt; 0) &#123;
    CFHTTPMessageSetHeaderFieldValue(responseMessage, CFSTR(&quot;Sec-WebSocket-Accept&quot;), (__bridge CFStringRef)acceptValue);
&#125;

CFDataRef data = CFHTTPMessageCopySerializedMessage(responseMessage);
[self writeData:(__bridge NSData*)data withCompletionBlock:^(BOOL sucess) &#123;&#125;];
CFRelease(data);
</code></pre>
<p>}</code></pre></div></p>
<h2 id="section_6">发送和接收信息</h2>

<p>下面两段代码分别是，从服务端发送信息到前端和服务端接收前端发来的信息。其中关于字节流的处理见 WebSocket 协议 Frame 的定义。</p>
<div class="code"><pre><code>- (void)sendMessage:(NSString *)msg &#123;
    NSData *msgData = [msg dataUsingEncoding:NSUTF8StringEncoding];
    NSMutableData *data = nil;

<pre><code>NSUInteger length = msgData.length;
if (length &lt;= 125) &#123;
    data = [NSMutableData dataWithCapacity:(length + 2)];
    [data appendBytes:&quot;\x81&quot; length:1];
    UInt8 len = (UInt8)length;
    [data appendBytes:&amp;len length:1];
    [data appendData:msgData];
&#125; else if (length &lt;= 0xFFFF) &#123;
    data = [NSMutableData dataWithCapacity:(length + 4)];
    [data appendBytes:&quot;\x81\x7E&quot; length:2];
    UInt16 len = (UInt16)length;
    [data appendBytes:(UInt8[])&#123;len &gt;&gt; 8, len &amp; 0xFF&#125; length:2];
    [data appendData:msgData];
&#125; else &#123;
    data = [NSMutableData dataWithCapacity:(length + 10)];
    [data appendBytes:&quot;\x81\x7F&quot; length:2];
    [data appendBytes:(UInt8[])&#123;0, 0, 0, 0, (UInt8)(length &gt;&gt; 24), (UInt8)(length &gt;&gt; 16), (UInt8)(length &gt;&gt; 8), length &amp; 0xFF&#125; length:8];
    [data appendData:msgData];
&#125;

[self writeData:data withCompletionBlock:^(BOOL success) &#123;&#125;];
</code></pre>
<p>}</code></pre></div></p>
<div class="code"><pre><code>- (void)handleReceivedData:(NSData *)data &#123;
    NSUInteger curPointPos = 0;     // pointer postion cursor
    NSUInteger msgLength;           // payload length
    NSUInteger opCode;
    BOOL frameMasked;
    NSData *maskingKey;

<pre><code>NSData *tmp = [[NSData alloc] initWithBytes:(UInt8 *)[data bytes] length:1];// first byte
curPointPos++;

UInt8 frame = *(UInt8 *)[tmp bytes];
if ([self isValidWebSocketFrame:frame]) &#123;
    opCode = frame &amp; 0x0F;
&#125; else &#123;
    [self closeWebSocket];
    return;
&#125;

tmp = [[NSData alloc] initWithBytes:((UInt8 *)[data bytes] + curPointPos) length:1];
curPointPos++;

frame = *(UInt8 *)[tmp bytes];
frameMasked = WS_PAYLOAD_IS_MASKED(frame);
NSUInteger length = WS_PAYLOAD_LENGTH(frame);

if (length &lt;= 125) &#123;
    if (frameMasked) &#123;
        maskingKey = [[NSData alloc] initWithBytes:((UInt8 *)[data bytes] + curPointPos) length:4];
        curPointPos += 4;
    &#125;
    msgLength = length;
&#125; else if (length == 126) &#123;
    tmp = [[NSData alloc] initWithBytes:((UInt8 *)[data bytes] + curPointPos) length:2];
    curPointPos += 2;

    UInt8 *pFrame = (UInt8 *)[tmp bytes];
    NSUInteger length = ((NSUInteger)pFrame[0] &lt;&lt; 8) | (NSUInteger)pFrame[1];
    if (frameMasked) &#123;
        maskingKey = [[NSData alloc] initWithBytes:((UInt8 *)[data bytes] + curPointPos) length:4];
        curPointPos += 4;
    &#125;
    msgLength = length;
&#125; else &#123;
    tmp = [[NSData alloc] initWithBytes:((UInt8 *)[data bytes] + curPointPos) length:8];
    curPointPos += 8;
    // FIXME: 64bit data size in memory?
    [self closeWebSocket];
    return;
&#125;

NSData *remainingData = [[NSData alloc] initWithBytes:((UInt8 *)[data bytes] + curPointPos) length:msgLength];
if (frameMasked &amp;&amp; maskingKey) &#123;
    NSMutableData *masked = [remainingData mutableCopy];
    UInt8 *pData = (UInt8 *)masked.mutableBytes;
    UInt8 *pMask = (UInt8 *)maskingKey.bytes;
    for (NSUInteger i = 0; i &lt; msgLength; i++) &#123;
        pData[i] = pData[i] ^ pMask[i % 4];
    &#125;
    remainingData = masked;
&#125;
if (opCode == WS_OP_TEXT_FRAME) &#123;
    NSString *msg = [[NSString alloc] initWithBytes:[remainingData bytes] length:msgLength encoding:NSUTF8StringEncoding];
    [self didReceiveMessage:msg];

    if (self.isReadSourceSuspended) &#123;
        // current reading finished, prepare for the next read event
        dispatch_resume(self.readSource);
        self.socketFDBytesAvailable = 0;
    &#125;
&#125; else &#123;
    [self closeWebSocket];
&#125;
</code></pre>
<p>}<br></code></pre></div></p>
<h2 id="section_7">遇到的问题</h2>

<h3>HSDGWebSocket 实例无法释放问题</h3>

<p>HSDGWebSocket 使用 dispatch_source 监听客户端 Socket 文件描述符。如果有数据可以读取，则 event_handler 会读取并解析数据。</p>
<p>最初的实现中设置了 dispatch_source_set_cancel_handler，如果接收到 WebSocket 关闭的信息，调用 dispatch_source_cancel，cancel_handler 会负责执行清理的工作，比如关闭 Socket 文件描述符。但是，测试下来发现，调用 dispatch_source_cancel 并没有触发 cancel_handler 的执行，并且，event_handler 的 block 实例不会释放，而且一直持有着 HSDGWebSocket 实例。</p>
<p>使用另外一种方法解决了这个问题。不再设置 dispatch_source_set_cancel_handler，如果接收到 WebSocket 关闭的信息，主动去执行清理的工作。并且 dispatch_source_set_event_handler 的 block 弱引用 HSDGWebSocket，解决 HSDGWebSocket 无法释放的问题。</p>
<p>dispatch_source_cancel 没有触发 cancel_handler 的原因还不知道。当前的做法可能仍然存在 dispatch_source_set_event_handler 的 block 实例一直未释放的问题。</p>
<h3>参考文献：</h3>

<p><a href="https://github.com/abbshr/abbshr.github.io/issues/22" target="_blank">学习WebSocket协议—从顶层到底层的实现原理（修订版）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2019/06/15/hsd-websocket/" data-id="ckrsyk6uv000vaqnbgnoy6ip5" data-title="为 GCDWebServer 引入 WebSocket 支持" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/06/hsb-practitioners-primer/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          HSB 颜色系统实践入门（译）
        
      </div>
    </a>
  
  
    <a href="/2019/06/10/js-date-and-zone/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JavaScript Date 和时区</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/31/open-yale-courses-death/">耶鲁大学公开课:死亡-读后感</a>
          </li>
        
          <li>
            <a href="/2021/01/09/different-problems/">简单问题、复杂问题、混沌问题</a>
          </li>
        
          <li>
            <a href="/2020/12/27/read-with-my-son/">与儿子一起的睡前阅读</a>
          </li>
        
          <li>
            <a href="/2020/12/05/different-sales/">不同的销售</a>
          </li>
        
          <li>
            <a href="/2020/08/08/child-reading/">如何开发孩子的阅读潜力</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 陈军<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>