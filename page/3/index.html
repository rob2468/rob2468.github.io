<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>陈军的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="陈军的博客">
<meta property="og:url" content="https://rob2468.github.io/page/3/index.html">
<meta property="og:site_name" content="陈军的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="陈军">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="陈军的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">陈军的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rob2468.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-clipped-content" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/12/clipped-content/" class="article-date">
  <time class="dt-published" datetime="2018-10-12T00:00:00.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/12/clipped-content/">视图裁剪</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1></h1>

<h2>前言</h2>

<p><a href="https://github.com/rob2468/HttpServerDebug" target="_blank">HttpServerDebug</a> 实现了类似 Xcode Debug View Hierarchy 功能。客户端提供信息，前端绘制并提供交互能力，实现视图调试功能。</p>
<p>视图调试其中一项功能是 Show Clipped Content，虽然不知道 Xcode 的实现方式，但是通过计算我们也可以拿到同样的信息。本文说明 HttpServerDebug 中的实现方案。</p>
<h2>效果图</h2>

<!-- <p class="post-image">
    <img src="/resources/figures/2018-10-12-hsd-clipped-content.png" alt="HttpServerDebug Show Clipped Content" width="90%">
</p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-10-12-hsd-clipped-content.png"></p>
<p class="post-image-title">HttpServerDebug 效果截图</p>

<!-- <p class="post-image">
    <img src="/resources/figures/2018-10-12-xcode-clipped-content.png" alt="Xcode Show Clipped Content" width="90%">
</p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-10-12-xcode-clipped-content.png"></p>
<p class="post-image-title">Xcode 效果截图</p>

<p>上面一组截图是 HttpServerDebug 运行效果，下面一组截图是 Xcode 中的原生效果。</p>
<h2>代码实现</h2>

<p>下面代码的目的是计算目标视图的位置和尺寸。</p>
<p>需要注意的是，代码中获取的 CGRect 信息来自于视图的 bounds 属性而不是 frame。bounds 可以理解为目标视图的内容在自己的坐标系统中的位置和尺寸，frame 是目标视图在父视图坐标系统中的位置和尺寸。我们使用了一系列转换函数实现不同坐标系统中的位置和尺寸转换，所以不需要直接获取 frame 属性。</p>
<div class="code"><pre><code>// view：UIView，目标视图
// window：UIWindow，view 属于该 window 视图层级
CGRect tryClippedRect = view.bounds;
UIView *tryView = view;
while (tryView.superview) &#123;
    UIView *superview = tryView.superview;

<pre><code>// 目标视图的位置和尺寸转换到父类的坐标系统中
tryClippedRect = [tryView convertRect:tryClippedRect toView:superview];

if (!CGSizeEqualToSize(tryClippedRect.size, CGSizeMake(0, 0)) &amp;&amp;
    superview.clipsToBounds) &#123;
    // 需要裁剪
    CGRect baseRect = superview.bounds;
    tryClippedRect = CGRectIntersection(tryClippedRect, baseRect);
    tryClippedRect = CGRectIsNull(tryClippedRect) ? CGRectZero : tryClippedRect;
&#125;
tryView = superview;
</code></pre>
<p>}<br>// 在 window 坐标系统中的位置和尺寸<br>CGRect clippedFrameRoot = tryClippedRect;<br></code></pre></div></p>
<p>上面代码只是计算出了位置和尺寸，调试界面显示还需要对目标视图进行截图，如下面代码所示。</p>
<p>（默认截图会包含目标视图的子视图，否则需要在截图前先移除或隐藏所有的子视图。）</p>
<div class="code"><pre><code>// 目标视图坐标系统中的裁剪位置
CGPoint clippedOrigin = [view convertPoint:clippedFrameRoot.origin fromView:window];

<p>// 截图<br>UIGraphicsBeginImageContextWithOptions(clippedFrameRoot.size, NO, 0.0);<br>CGContextRef context = UIGraphicsGetCurrentContext();<br>CGFloat tx = -clippedOrigin.x;<br>CGFloat ty = -clippedOrigin.y;<br>CGContextTranslateCTM(context, tx, ty);<br>[view.layer renderInContext:context];<br>UIImage *snapshot = UIGraphicsGetImageFromCurrentImageContext();<br>UIGraphicsEndImageContext();<br></code></pre></div></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/10/12/clipped-content/" data-id="cl4h5hf3e000obdoo2ervdq03" data-title="视图裁剪" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-block" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/30/block/" class="article-date">
  <time class="dt-published" datetime="2018-09-30T00:00:00.000Z" itemprop="datePublished">2018-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/30/block/">Objective-C Block</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 class="title"></h1>

<h2>前言</h2>

<p>本文内容主要来自 Pro Multithreading and Memory Management for iOS and OS X with ARC, Grand Central Dispatch, and Blocks 这本书，参考<a href="/2016/12/29/Reading-Notes-Pro-Multithreading-and-Memory-Management-for-iOS-and-OSX-with-ARC-Grand_Central-Dispatch-and-Blocks.html">这篇文章</a>。</p>
<p>Block 是语言级别的语法，是 C 语言的扩展。Block 可以解释为“包含了局部变量的匿名函数（anonymous functions together with automatic (local) variables）”。本文不多说 Block 的使用方法，着重讨论 Block 的实现机制。</p>
<h2 id="section_1">一、Block 的基本实现</h2>

<p>可以使用指令 <code>clang -rewrite-objc file_name_of_the_source_code</code>，将 OC 源代码转换成对应的 C++ 实现，从而探究 Block 的实现原理。</p>
<p>原始代码：</p>
<div class="code"><pre><code>int main()
&#123;
    void (^blk)(void) = ^&#123;printf("Block\n");&#125;;
    blk();
    return 0;
&#125;
</code></pre></div>

<p>转换后代码：</p>
<div class="code"><pre><code>struct __block_impl &#123;
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
&#125;;

<p>struct __main_block_impl_0 &#123;<br>    struct __block_impl impl;<br>    struct __main_block_desc_0 *Desc;<br>    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;</p>
<p>static void __main_block_func_0(struct __main_block_impl_0 *__cself)<br>&#123;<br>    printf(“Block\n”);<br>&#125;</p>
<p>static struct __main_block_desc_0<br>&#123;<br>    unsigned long reserved;<br>    unsigned long Block_size;<br>&#125; __main_block_desc_0_DATA = &#123;<br>    0,<br>    sizeof(struct __main_block_impl_0)<br>&#125;;</p>
<p>int main() &#123;<br>    void (<em>blk)(void) =<br>        (void (</em>)(void))&amp;__main_block_impl_0((void <em>)__main_block_func_0, &amp;__main_block_desc_0_DATA);<br>    ((void (</em>)(struct __block_impl *))((struct __block_impl *)blk)-&gt;FuncPtr)((struct __block_impl *)blk);<br>    return 0;<br>&#125;<br></code></pre></div></p>
<p>对比原始代码，转换后的代码增加了三个结构体和一个函数的定义。结构体：__block_impl、__main_block_impl_0、__main_block_desc_0；函数：__main_block_func_0。__main_block_func_0 对应原始代码中的 Block 实现，函数命名的规则是取原始方法名（main）和该 Block 在原始方法中的次序（第0个），结构体的命名规则也是如此。</p>
<h2 id="section_2">二、isa 和 _NSConcreteStackBlock</h2>

<p>上小节 __main_block_impl_0 的构造函数中有赋值语句 <code>impl.isa = &amp;_NSConcreteStackBlock</code>，本小节简述 isa 和 _NSConcreteStackBlock 的含义。</p>
<p>OC 中的对象实例和类编译后都有其对应的结构体定义，如下所示。</p>
<p>对象实例对应的结构体：</p>
<div class="code"><pre><code>/* declared in /usr/include/objc/objc.h */
struct objc_object &#123;
    Class isa;
&#125;
</code></pre></div>

<p>类对应的结构体：</p>
<div class="code"><pre><code>/* declared in /usr/include/objc/runtime.h */
struct objc_class &#123;
    Class isa;
&#125;;

<p>typedef struct objc_class *Class;</p>
<p>/* declared at runtime/objc-runtime-new.h in the objc4 runtime library */<br>struct class_t &#123;<br>    struct class_t *isa;<br>    struct class_t *superclass;<br>    Cache cache;<br>    IMP *vtable;<br>    uintptr_t data_NEVER_USE;<br>&#125;;<br></code></pre></div></p>
<p>OC 中的类使用 class_t 构造（class_t 本身基于 objc_class），也就是说 OC 中的每个类都使用 class_t 创建了实例。比如，NSObject 有其对应的 class_t 实例，NSMutableArray 有其对应的 class_t 实例。class_t 实例保存了类的信息，如方法名、方法实现、指向父类的指针等，提供给 OC 运行时库使用。</p>
<p>基于上面描述，下图描述 isa 值的含义。</p>
<!-- <p class="post-image"><img src="/resources/figures/2016-12-29-Objective-C-class-and-object.png" alt="" width="80%"></p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2016-12-29-Objective-C-class-and-object.png"></p>
<p class="post-image-title">图 OC 对象和类中 isa 指针的指向</p>

<p>__main_block_impl_0 结构体基于 objc_object，表明 Block 本身即为 OC 对象。创建 Block 时执行语句 <code>impl.isa = &amp;_NSConcreteStackBlock</code>。根据上文描述，_NSConcreteStackBlock 是 class_t 实例，保存了该 Block 对应的类的信息。</p>
<h2 id="section_3">三、Block 捕获自动变量</h2>

<p>Block 能够捕获自动变量。下面使用 <code>clang -rewrite-objc file_name_of_the_source_code</code> 指令转换代码，描述了在这种情况下 Block 实现方式的变化。（__block_impl、__main_block_desc_0、__main_block_desc_0_DATA的声明和定义与上文相同，不再描述）</p>
<p>原始代码：</p>
<div class="code"><pre><code>int main() &#123;
    int dmy = 256;
    int val = 10;
    const char *fmt = "val = %d\n";
    void (^blk)(void) = ^&#123;printf(fmt, val);&#125;;
    return 0;
&#125;
</code></pre></div>

<p>转换后代码：</p>
<div class="code"><pre><code>struct __main_block_impl_0 &#123;
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    const char *fmt;
    int val;

<pre><code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0)
    : fmt(_fmt), val(_val) &#123;
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
&#125;
</code></pre>
<p>};</p>
<p>static void __main_block_func_0(struct __main_block_impl_0 *__cself)<br>{<br>    const char *fmt = __cself-&gt;fmt;<br>    int val = __cself-&gt;val;<br>    printf(fmt, val);<br>}</p>
<p>int main() {<br>    int dmy = 256;<br>    int val = 10;<br>    const char *fmt = “val = %d\n”;<br>    void (*blk)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val);<br>  return 0;<br>}<br></code></pre></div></p>
<p>__main_block_impl_0 为 Block 对象的定义，在这种情况下，其中增加了两个成员变量（fmt 和 val）用来存储捕获的自动变量。Block 不会捕获未使用的自动变量（dmy）。</p>
<h2 id="section_4">四、Block 中修改静态变量、静态全局变量和全局变量</h2>

<p>Block 中能够修改静态变量、静态全局变量和全局变量的值，但是底层实现机制存在差异。下面给出转换前后的代码，并给出说明。</p>
<p>原始代码：</p>
<div class="code"><pre><code>int global_val = 1;
static int static_global_val = 2;
int main()
&#123;
    static int static_val = 3;
    void (^blk)(void) = ^&#123;
        global_val *= 1;
        static_global_val *= 2;
        static_val *= 3;
    &#125;;
    return 0;
&#125;
</code></pre></div>

<p>转换后代码：</p>
<div class="code"><pre><code>int global_val = 1;
static int static_global_val = 2;

<p>struct __main_block_impl_0 &#123;<br>    struct __block_impl impl;<br>    struct __main_block_desc_0 *Desc;<br>    int *static_val;<br>    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0)<br>        : static_val(_static_val) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;</p>
<p>static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>    int *static_val = __cself-&gt;static_val;</p>
<pre><code>global_val *= 1;
static_global_val *= 2;
(*static_val) *= 3;
</code></pre>
<p>}</p>
<p>int main()<br>{<br>    static int static_val = 3;</p>
<pre><code>blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val);
return 0;
</code></pre>
<p>}<br></code></pre></div></p>
<p>静态全局变量和全局变量的处理方式是一致的，Block 能够直接对其进行读写。</p>
<p>静态变量的可见性只是当前函数内，转换后的代码中 __main_block_func_0 无法访问。在 __main_block_impl_0 中增加指向静态变量指针的成员变量，通过该成员变量实现读写静态变量。</p>
<p>前文说到 Block 能够捕获自动变量，但是不能修改其值。自动变量的生命周期跟随其所在的作用域，离开作用域即销毁。Block 的生命周期可能会长于自动变量的生命周期，所以无法采用读写静态变量的实现方案。</p>
<h2 id="section_5">五、Block 中修改 __block 变量</h2>

<p>原始代码：</p>
<div class="code"><pre><code>int main() &#123;
    __block int val = 10;
    void (^blk)(void) = ^&#123;val = 1;&#125;;
    return 0;
&#125;
</code></pre></div>

<p>转换后代码：</p>
<div class="code"><pre><code>struct __Block_byref_val_0 &#123;
    void *__isa;
    __Block_byref_val_0 *__forwarding;
    int __flags;
    int __size;
    int val;
&#125;;

<p>struct __main_block_impl_0 &#123;<br>    struct __block_impl impl;<br>    struct __main_block_desc_0 *Desc;<br>    __Block_byref_val_0 *val;<br>    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0)<br>        : val(_val-&gt;__forwarding) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;</p>
<p>static void __main_block_func_0(struct __main_block_impl_0 *__cself)<br>&#123;<br>    __Block_byref_val_0 *val = __cself-&gt;val;<br>    (val-&gt;__forwarding-&gt;val) = 1;<br>&#125;</p>
<p>static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)<br>&#123;<br>    _Block_object_assign(&amp;dst-&gt;val, src-&gt;val, BLOCK_FIELD_IS_BYREF);<br>&#125;</p>
<p>static void __main_block_dispose_0(struct __main_block_impl_0 *src)<br>&#123;<br>    _Block_object_dispose(src-&gt;val, BLOCK_FIELD_IS_BYREF);<br>&#125;</p>
<p>static struct __main_block_desc_0 &#123;<br>    unsigned long reserved;<br>    unsigned long Block_size;<br>    void (<em>copy)(struct __main_block_impl_0</em>, struct __main_block_impl_0*);<br>    void (<em>dispose)(struct __main_block_impl_0</em>);<br>&#125; __main_block_desc_0_DATA = &#123;<br>    0,<br>    sizeof(struct __main_block_impl_0),<br>    __main_block_copy_0,<br>    __main_block_dispose_0<br>&#125;;</p>
<p>int main()<br>&#123;<br>    __Block_byref_val_0 val = &#123;<br>        0,<br>        &amp;val,<br>        0,<br>        sizeof(__Block_byref_val_0),<br>        10<br>    &#125;;<br>    blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;val, 0x22000000);<br>    return 0;<br>&#125;<br></code></pre></div></p>
<p>转换后的代码中，原始 __block 变量转换成了 __Block_byref_val_0 结构体类型。__Block_byref_val_0 的成员变量 val 存储原始值。</p>
<p>__Block_byref_val_0 实例和 __main_block_impl_0 实例是多对多的关系，即一个 __Block_byref_val_0 实例可以在多个 __main_block_impl_0 实例中使用，一个 __main_block_impl_0 实例也可以使用多个 __Block_byref_val_0 实例。</p>
<h2 id="section_6">六、Block 的存储类型</h2>

<p>上文可知 Block 本身也是 OC 对象，其在内存中的存储方式有三种：_NSConcreteStackBlock、_NSConcreteGlobalBlock、_NSConcreteMallocBlock，分别对应：栈、全局/静态存储区、堆。内存区域划分方式大致可用下图表示，下图同时描述了不同存储方式的 Block 对应的内存区域。</p>
<!-- <p class="post-image"><img src="/resources/figures/2016-12-29-Memory-segments-for-Blocks.png" alt="" width="70%"></p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2016-12-29-Memory-segments-for-Blocks.png"></p>
<p class="post-image-title">图 Block 不同存储方式对应的内存区域</p>

<p>Block 字面定义在全局作用域生成 _NSConcreteGlobalBlock 类型 Block 对象。</p>
<p>存储类型为 _NSConcreteStackBlock 的 Block 以及 __block 修饰的变量的生命周期与普通自动变量相同，离开作用域后即销毁。</p>
<h2 id="section_7">七、Block 的存储类型 -- 堆上的 Block</h2>

<p>堆上的 Block 即存储类型为 _NSConcreteMallocBlock 的 Block。_NSConcreteStackBlock 存储类型的 Block 可以从栈拷贝到堆上。下图为 Block 从栈拷贝到堆的示意图，同样的，__block 变量也可以从栈拷贝到堆。</p>
<!-- <p class="post-image"><img src="/resources/figures/2016-12-29-A-Block-and-__block-copied-from-the-stack-to-the-heap.png" alt="" width="80%"></p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2016-12-29-A-Block-and-__block-copied-from-the-stack-to-the-heap.png"></p>
<p class="post-image-title">图 Block 和 __block 变量从栈拷贝到堆</p>

<p>在下列情况下，栈中的 Block 会拷贝到堆：</p>
<p>a. 调用 Block 对象的 copy 方法；</p>
<p>b. 函数返回值为 Block 对象；</p>
<p>c. Block 对象赋给 __strong 所有权描述符修饰的变量；</p>
<p>d. Block 对象被 Cocoa 框架中的 “usingBlock” 方法使用，或者被 GCD 中的函数使用。</p>
<p>不同存储类型的 Block 对象调用 copy 方法的效果不同：</p>
<p> a. _NSConcreteStackBlock 类型的 Block 对象，从栈拷贝到堆；</p>
<p> b. _NSConcreteGlobalBlock 类型的 Block 对象，不发生作用；</p>
<p> c. _NSConcreteMallocBlock 类型的 Block 对象，引用计数加一。（在 ARC 开启的情况下，多次调用 copy 方法也没有问题。）</p>
<h2 id="section_8">八、__block 变量</h2>

<p>当 Block 使用了 __block 变量并且 Block 从栈拷贝到堆时：如果 __block 变量存储在栈上，__block 变量会被拷贝到堆上，并且 Block 对象拥有 __block 变量的所有权；如果 __block 变量本来即存储在堆上，Block 也会拥有 __block 变量的所有权。</p>
<p>__block 变量编译后也是普通的结构体实例，其中有个特别的成员变量 __forwarding。通过 __forwarding 成员变量保证访问 __block 变量的一致性。如下代码片段，__block 变量随着 Block 从栈拷贝到堆上。</p>
<div class="code"><pre><code>__block int val = 0;
void (^blk)(void) = [^&#123;++val;&#125; copy];
++val;
blk();
</code></pre></div>

<p>Block 内部会修改堆上的 __block 变量，Block 外部会修改栈上的 __block 变量。转换后，这两种行为是一致的，即<code>++(val.__forwarding-&gt;val)</code>。栈和堆上 __block 变量中的 __forwarding 指针都指向堆上的 __block 变量，下图描述了这种机制。</p>
<!-- <p class="post-image"><img src="/resources/figures/2016-12-29-Copying-a-__block-variable.png" alt="" width="80%"></p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2016-12-29-Copying-a-__block-variable.png"></p>
<p class="post-image-title">图 __block 变量拷贝到堆</p>

<h2 id="section_9">九、Block 捕获对象实例</h2>

<p>前文讲述的 Block 捕获自动变量，自动变量的类型为整型变量。当 Block 捕获的自动变量为 OC 对象时：</p>
<p>原始代码：</p>
<div class="code"><pre><code>blk_t blk;
&#123;
    id array = [[NSMutableArray alloc] init];
    blk = [^(id obj) &#123;
        [array addObject:obj];
        NSLog(@"array count = %ld", [array count]);
    &#125; copy];
&#125;
blk([[NSObject alloc] init]);
blk([[NSObject alloc] init]);
blk([[NSObject alloc] init]);
</code></pre></div>

<p>转换后代码：</p>
<div class="code"><pre><code>/* a struct for the Block and some functions */
struct __main_block_impl_0 &#123;
    struct __block_impl impl;
    struct __main_block_desc_0 *Desc;
    id __strong array;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0)
        : array(_array) &#123;
        impl.isa = &_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    &#125;
&#125;;

<p>static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)<br>&#123;<br>    id __strong array = __cself-&gt;array;<br>    [array addObject:obj];<br>    NSLog(@”array count = %ld”, [array count]);<br>&#125;</p>
<p>static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)<br>&#123;<br>    _Block_object_assign(&amp;dst-&gt;array, src-&gt;array, BLOCK_FIELD_IS_OBJECT);<br>&#125;</p>
<p>static void __main_block_dispose_0(struct __main_block_impl_0 *src)<br>&#123;<br>    _Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);<br>&#125;</p>
<p>static struct __main_block_desc_0 &#123;<br>    unsigned long reserved;<br>    unsigned long Block_size;<br>    void (<em>copy)(struct __main_block_impl_0</em>, struct __main_block_impl_0*);<br>    void (<em>dispose)(struct __main_block_impl_0</em>);<br>&#125; __main_block_desc_0_DATA = &#123;<br>    0,<br>    sizeof(struct __main_block_impl_0),<br>    __main_block_copy_0,<br>    __main_block_dispose_0<br>&#125;;</p>
<p>/* Block literal and executing the Block */<br>blk_t blk;<br>&#123;<br>    id __strong array = [[NSMutableArray alloc] init];<br>    blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, array, 0x22000000);<br>    blk = [blk copy];<br>&#125;<br>(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);<br>(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);<br>(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);<br></code></pre></div></p>
<h2 id="section_10">十、内存管理</h2>

<p>前文讲述到 Block 内存管理时提到对象之间的所有权关系，但是转换后的 C 代码是无法利用 ARC 机制的。本小节说明相关的内存管理是如何实现的。</p>
<h4>10.1 Block 内的内存管理实现</h4>

<p>在前文中，当 Block 对象需要引用对象时，比如捕获 __block 变量、捕获 OC 对象实例，__main_block_desc_0 结构体中多了两个成员变量 copy 和 dispose，他们都为函数指针，函数实现如下代码所示。copy 和 dispose 分别对应对象的初始化和销毁，OC 运行时检测到 Block 从栈拷贝到堆或者 Block 对象被销毁时，能够适时调用 copy 和 dispose 实现 Block 内的内存管理。</p>
<p>Block 捕获 __block 变量内存管理相关代码：</p>
 <div class="code"><pre><code>static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)
&#123;
    _Block_object_assign(&dst->val, src->val, BLOCK_FIELD_IS_BYREF);
&#125;

<p>static void __main_block_dispose_0(struct __main_block_impl_0 *src)<br>&#123;<br>    _Block_object_dispose(src-&gt;val, BLOCK_FIELD_IS_BYREF);<br>&#125;<br></code></pre></div></p>
<p>Block 捕获对象实例内存管理相关代码：</p>
<div class="code"><pre><code>static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)
&#123;
    _Block_object_assign(&dst->array, src->array, BLOCK_FIELD_IS_OBJECT);
&#125;

<p>static void __main_block_dispose_0(struct __main_block_impl_0 *src)<br>&#123;<br>    _Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);<br>&#125;<br></code></pre></div></p>
<h4>10.2 __block 变量内的内存管理实现</h4>

<p>当 __block 修饰的变量为 OC 对象实例时，__block 内部需要负责该对象实例的内存管理。如下代码所示。__block 变量内的内存管理实现和 Block 内的内存管理类似。该情况下，__Block_byref_obj_0 结构体中多了两个成员变量 __Block_byref_id_object_copy 和 __Block_byref_id_object_dispose，都为函数指针，作用与上小节的 copy 和 dispose 相同，OC 运行时检测到 __block 变量从栈拷贝到堆或者 __block 变量被销毁时，适时调用这对方法，实现 __block 变量内的内存管理。</p>
<p>原始代码：</p>
<div class="code"><pre><code>__block id obj = [[NSObject alloc] init];
</code></pre></div>

<p>转换后代码：</p>
<div class="code"><pre><code>/* struct for __block variable */
struct __Block_byref_obj_0 &#123;
    void *__isa;
    __Block_byref_obj_0 *__forwarding;
    int __flags;
    int __size;
    void (*__Block_byref_id_object_copy)(void*, void*);
    void (*__Block_byref_id_object_dispose)(void*);
    __strong id obj;
&#125;;

<p>static void __Block_byref_id_object_copy_131(void *dst, void <em>src) &#123;<br>    _Block_object_assign((char</em>)dst + 40, *(void * <em>) ((char</em>)src + 40), 131);<br>&#125;</p>
<p>static void __Block_byref_id_object_dispose_131(void <em>src) &#123;<br>    _Block_object_dispose(</em>(void * <em>) ((char</em>)src + 40), 131);<br>&#125;</p>
<p>/* __block variable declaration */<br>__Block_byref_obj_0 obj = &#123;<br>    0,<br>    &amp;obj,<br>    0x2000000,<br>    sizeof(__Block_byref_obj_0),<br>    __Block_byref_id_object_copy_131,<br>    __Block_byref_id_object_dispose_131,<br>    [[NSObject alloc] init]<br>&#125;;<br></code></pre></div></p>
<h2 id="section_11">十一、ARC 下 Block 得存储类型变化</h2>

<p>_NSConcreteGlobalBlock：这种类型的 block 定义在全局存储区，它没有捕获任何上下文，在编译时就能完全定义。</p>
<p>_NSConcreteStackBlock：这种类型的 block 定义在栈上。block 在被拷贝到堆上之前，都是存储在栈中。</p>
<p>_NSConcreteMallocBlock：这种类型的 block 存储在堆上。和普通 OC 对象遵循同样的内存管理规则（引用计数）。</p>
<p>MRC 和 ARC 的 block 存储有差异，“在 ARC 开启的情况下，将只会有 NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 block。”</p>
<h2 id="section_12">十二、案例分析</h2>

<h3>案例</h3>

<p>下面的代码显然存在内存泄漏，有 self -&gt; blk -&gt; self 这样的循环引用。那内存泄漏是哪个环节导致的，是位置 A，还是位置 B？</p>
<div class="code"><pre><code>@interface TestObject : NSObject
@property (nonatomic, copy) dispatch_block_t blk;
@end
@implementation TestObject
- (instancetype)init &#123;
    self = [super init];
    if (self) &#123;
        self.blk = ^&#123;               // A
            [self emptyMethod];
        &#125;;
        self.blk();                 // B
    &#125;
    return self;
&#125;
- (void)emptyMethod &#123;
    NSLog(@"hello");
&#125;
@end
</code></pre></div>

<p>使用 Instruments 能够分析出位置 A 便引入了循环引用。参考 <a href="#section_9">九、Block 捕获对象实例</a>，Block 实例化的时候，外部对象实例在其构造函数中就被强引用。所以 Block 定义的时候就已经产生了循环引用，而不用等到执行的时候。</p>
<h3>参考文献：</h3>

<p>Sakamoto, Kazuki, and Tomohiko Furumoto. Pro Multithreading and Memory Management for IOS and OS X. Apress, 2012.</p>
<p><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/" target="_blank">A look inside blocks: Episode 2</a></p>
<p>唐巧 . <a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#ARC-%E5%AF%B9-block-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%B1%E5%93%8D" target="_blank">谈Objective-C block的实现 – ARC 对 block 类型的影响</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/09/30/block/" data-id="cl4h5hf4f001abdoo0ixf309e" data-title="Objective-C Block" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-sort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/17/sort/" class="article-date">
  <time class="dt-published" datetime="2018-09-17T00:00:00.000Z" itemprop="datePublished">2018-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/17/sort/">排序算法，伪代码实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 class="title"></h1>

<h2 id="section_1">一、插入排序</h2>

<h3 id="section_1_1">1. 直接插入排序</h3>

<div class="code"><pre><code>/**
 * 使用插入排序算法，将目标数组从小到大排列
 * @param array  待排序的目标数组
 * @param n  数组长度
 */
void InsertSort(int array[], int n) &#123;
    int i, j;
    int tmp;
    for (i = 1; i < n; i++) &#123;
        // 遍历待排序元素
        tmp = array[i];
        for (j = i - 1; j >= 0 && array[j] > tmp; j--) &#123;
            // 遍历已排序元素
            array[j + 1] = array[j];
        &#125;
        array[j + 1] = tmp;
    &#125;
&#125;
</code></pre></div>

<p>时间复杂度 O(n^2)，空间复杂度 O(1)。直接插入排序是稳定的排序算法。</p>
<h3 id="section_1_2">2. 希尔排序</h3>

<div class="code"><pre><code>/**
 * 使用希尔排序算法，将目标数组从小到大排列
 * @param arrray  待排序的目标数组
 * @param n  数组长度
 */
void ShellSort(int array[], int n) &#123;
    int dk, i, j;
    int tmp;
    for (dk = n / 2; dk >= 1; dk = dk / 2) &#123;
        // 步长变化
        for (i = dk; i < n; i++) &#123;
            // 遍历待排序元素
            if (array[i] < array[i - dk]) &#123;
                tmp = array[i];
                for (j = i - dk; j >= 0 && tmp < array[j]; j -= dk) &#123;
                    // 遍历已排序元素
                    array[j + dk] = array[j];
                &#125;
                array[j + dk] = tmp;
            &#125; // if
        &#125;
    &#125;
&#125;
</code></pre></div>

<p>由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 n 在某个特定范围时，希尔排序的时间复杂度约为 O(n^1.3)。在最坏情况下希尔排序的时间复杂度为 O(n^2)。</p>
<p>空间复杂度 O(1)。</p>
<p>希尔排序是不稳定的排序算法。</p>
<h2 id="section_2">二、交换排序</h2>

<h3 id="section_2_1">1. 冒泡排序</h3>

<div class="code"><pre><code>/**
 * 使用冒泡排序算法，将目标数组从小到大排列
 * @param array  待排序的目标数组
 * @param n  数组长度
 */
void BubbleSort(int array[], int n) &#123;
    for (int i = 0; i < n - 1; i++) &#123;
        bool flag = false;     // 本趟冒泡是否发生交换的标志
        for (int j = n - 1; j > i; j--) &#123;
            if (array[j - 1] > array[j]) &#123;
                // 交换
                int tmp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = tmp;

<pre><code>            flag = true;
         &#125;
     &#125;
     if (!flag) &#123;
         // 本趟遍历没有发生交换，说明已有序
         break;
     &#125;
 &#125;
</code></pre>
<p> }<br></code></pre></div></p>
<p>时间复杂度 O(n^2)，空间复杂度 O(1)。冒泡排序是稳定的排序算法。</p>
<h3 id="section_2_2">2. 快速排序</h3>

<div class="code"><pre><code>/**
 * 使用快速排序算法，将目标数组从小到大排列
 * @param array  待排序的目标数组
 * @param low  起始下标
 * @param high  结束下标
 */
void QuickSort(int array[], int low, int high) &#123;
    if (low < high) &#123;
        int pivotPos = Partition(array, low, high); // 划分
        QuickSort(array, low, pivotPos - 1);
        QuickSort(array, pivotPos + 1, high);
    &#125;
&#125;
/**
 *  将数组划分成两个部分
 *  @param array  待排序的目标数组
 *  @param low  起始下标
 *  @param high  结束下标
 *  @return  已在最终位置元素的下标
 */
int Partition(int array[], int low, int high) &#123;
    int pivot = array[low];             // 将第一个元素设为枢轴值，对表进行划分
    while (low < high) &#123;
        while (low < high && array[high] >= pivot) &#123;
            --high;
        &#125;
        array[low] = array[high];       // 将比枢轴值小的元素移动到左端
        while (low < high && array[low] <= pivot) &#123;
            ++low;
        &#125;
        array[high] = array[low];       // 将比枢轴值大的元素移动到右端
    &#125;
    array[low] = pivot;                 // 枢轴值存放到最终位置
    return low;
&#125;
</code></pre></div>

<p>时间复杂度 O(nlogn)，空间复杂度 O(logn)。快速排序是不稳定的排序算法。</p>
<h2 id="section_3">三、选择排序</h2>

<h3 id="section_3_1">1. 简单选择排序</h3>

<div class="code"><pre><code>/**
 * 使用简单选择排序算法，将目标数组从小到大排列
 * @param array  待排序的目标数组
 * @param n  数组长度
 */
void SelectSort(int array[], int n) &#123;
    for (int i = 0; i < n - 1; i++) &#123;
        // 遍历所有待排序元素，每一轮遍历，找出最小元素并交换到最终位置
        int min = i;
        for (int j = i + 1; j < n; j++) &#123;
            if (array[j] < array[min]) &#123;
                min = j;
            &#125;
        &#125;
        if (min != i) &#123;
            // 交换
            int tmp = array[min];
            array[min] = array[i];
            array[i] = tmp;
        &#125;
    &#125;
&#125;
</code></pre></div>

<p>时间复杂度 O(n^2)，空间复杂度 O(1)。简单选择排序是不稳定的排序算法。</p>
<h3 id="section_3_2">2. 堆排序</h3>

<p>堆的定义如下：n 个关键字序列 L[1…n] 称为堆，当且仅当该序列满足：</p>
<p>(1) L(i) &lt;= L(2i) 且 L(i) &lt;= L(2i + 1) 或 (2) L(i) &gt;= L(2i) 且 L(i) &gt;= L(2i + 1)</p>
<p>（1 &lt;= i &lt;= n/2）</p>
<p>满足第(1)种情况的堆称为小根堆（小顶堆），满足第(2)种情况的堆称为大根堆（大顶堆）。</p>
<p>下面代码都是构造和维护大根堆。</p>
<div class="code"><pre><code>/**
 * 使用堆排序算法，将目标数组从小到大排列
 */
void HeapSort(int A[], int len) &#123;
    BuildMaxHeap(A, len);       // 初始建堆
    for (i = len; i > 1; i--) &#123;
        // n - 1 趟的交换和建堆过程
        // 输出堆顶元素（和堆底元素交换）
        int tmp = A[i];
        A[i] = A[1];
        A[1] = tmp;

<pre><code>    // 整理，把剩余的 i - 1 个元素整理成堆
    AdjustDown(A, 1, i - 1);
&#125; // for
</code></pre>
<p>}<br>/**</p>
<ul>
<li>建立大根堆，注意 A[0] 中不存储元素，实际存储从 A[1] 开始</li>
<li>/<br>void BuildMaxHeap(int A[], int len) {<br>  for (int i = len/2; i &gt; 0; i–) {   // 从 len/2 ~ 1，反复调整堆<pre><code>  AdjustDown(A, i, len);
</code></pre>
  }<br>}<br>/**</li>
<li>将元素 k 向下进行调整</li>
<li>/<br>void AdjustDown(int A[], int k, int len) {<br>  A[0] = A[k];            // A[0] 暂存<br>  for (i = 2 * k; i &lt;= len; i*= 2) {<pre><code>  // 沿 key 较大的子结点向下筛选
  if (i &lt; len &amp;&amp; A[i] &lt; A[i + 1]) &#123;
      // 取 key 较大的子结点的下标
      i++;
  &#125;
  if (A[0] &gt;= A[i]) &#123;
      // 筛选结束
      break;
  &#125; else &#123;
      A[k] = A[i];    // 将 A[i] 调整到双亲结点上
      k = i;          // 修改 k 值，以便继续向下筛选
  &#125;
</code></pre>
  } // for<br>  A[k] = A[0];            // 被筛选结点的值放入最终位置<br>}<br></code></pre></div></li>
</ul>
<div class="code"><pre><code>/**
 * 参数 k 为向上调整的结点，也为堆的元素个数
 */
void AdjustUp(int A[], int k) &#123;
    A[0] = A[k];
    int i = k / 2;  // 若结点值大于双亲结点，则将双亲结点向下调，并继续向上比较
    while (i > 0 && A[i] < A[0]) &#123;
        A[k] = A[i];
        k = i;
        i = k / 2;
    &#125; // while
    A[k] = A[0];
&#125;
</code></pre></div>

<p>注意：堆最重要的操作就是函数 AdjustDown 和 AdjustUp，其余操作均通过这两个操作完成。</p>
<p>时间复杂度 O(nlogn)，空间复杂度 O(1)。堆排序是不稳定的排序算法。</p>
<h2 id="section_4">四、归并排序</h2>

<h3 id="section_4_1">1. 二路归并排序</h3>

<div class="code"><pre><code>/**
 * 使用二路归并排序算法，将目标数组从小到大排列
 * @param array  待排序的目标数组
 * @param low  起始下标
 * @param high  结束下标
 */
void MergeSort(int array[], int low, int high) &#123;
    if (low < high) &#123;
        int mid = (low + high) / 2;
        MergeSort(array, low, mid);        // 对左侧子序列进行递归排序
        MergeSort(array, mid + 1, high);   // 对右侧子序列进行递归排序
        Merge(array, low, mid, high);          // 归并
    &#125;
&#125;
int *B = (int *)malloc((n) * sizeof(int));  // 辅助数组
void Merge(int array[], int low, int mid, int high) &#123;
    int i, j, k;
    for (k = low; k <= high; k++) &#123;
        // 将 array 中元素拷贝到 B 中
        B[k] = array[k];
    &#125;
    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) &#123;
        // 比较 B 中左右两段中的元素，将较小值拷贝到 array 中
        if (B[i] < B[j]) &#123;
            array[k] = B[i++];
        &#125; else &#123;
            array[k] = B[j++];
        &#125;
    &#125; // for
    // 下面两个 while 循环只有一个会执行
    while (i <= mid) &#123;
        // 第一个表未检测完
        array[k++] = B[i++];
    &#125;
    while (j <= high) &#123;
        // 第二个表未检测完
        array[k++] = B[j++];
    &#125;
 &#125;
</code></pre></div>

<p>时间复杂度 O(nlogn)，空间复杂度 O(n)。二路归并排序是稳定的排序算法。</p>
<p>原地归并排序不需要辅助数组即可归并，空间复杂度 O(1)。关键在于 Merge 函数，如下所示。</p>
<div class="code"><pre><code>/**
 * 将长度为 n 的数组逆序
 */
void reverse(int array[], int n) &#123;
    int i = 0;
    int j = n - 1;
    while (i < j) &#123;
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;

<pre><code>    i++;
    j--;
&#125;
</code></pre>
<p>}<br>/**</p>
<ul>
<li>将含有 n 个元素的数组向左循环移位 i 个位置</li>
<li>/<br>void exchange(int array[], int n, int i) {<br>  reverse(array, i);<br>  reverse(array + i, n - i);<br>  reverse(array, n);<br>}<br>void Merge(int array[], int low, int mid, int high) {<br>  int i = low;<br>  int j = mid + 1;<br>  while (i &lt; j &amp;&amp; j &lt;= high) {<pre><code>  int step = 0;
  while (i &lt; j &amp;&amp; array[i] &lt;= array[j]) &#123;
      i++;
  &#125;
  while (j &lt;= high &amp;&amp; array[j] &lt;= array[i]) &#123;
      j++;
      step++;
  &#125;
  // array + i 为子数组首地址，j - i 为子数组元素个数，j - i - step 为左循环移位的个数
  exchange(array + i, j - i, j - i - step);
  i += step;
</code></pre>
  }<br>}<br></code></pre></div></li>
</ul>
<h3 id="section_4_2">2. 多路归并排序</h3>

<p>外部排序指的是大文件的排序，即待排序的记录存储在外部存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p>
<p>外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序。</p>
<h3>参考文献：</h3>

<p>王道论坛. 程序员求职宝典. 电子工业出版社.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/09/17/sort/" data-id="cl4h5hf3b000nbdoofhji3g85" data-title="排序算法，伪代码实现" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-binary-tree-traverse" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/16/binary-tree-traverse/" class="article-date">
  <time class="dt-published" datetime="2018-09-16T00:00:00.000Z" itemprop="datePublished">2018-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/16/binary-tree-traverse/">二叉树的遍历，伪代码实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1></h1>

<div class="code"><pre><code>/**
 *  二叉树链表存储，结点数据模型
 */
struct BiTreeNode &#123;
    int data;
    BiTreeNode *lchild;
    BiTreeNode *rchild;
&#125;;
</code></pre></div>

<h3>递归算法</h3>

<div class="code"><pre><code>/**
 *  先序遍历二叉树，递归算法实现
 *  采用链表存储结构，对每个二叉树的结点数据调用 Visit 函数
 *  最简单的 Visit 函数功能之一，如打印传入参数
 */
void PreOrderTraverse(BiTreeNode *T) &#123;
    if (T) &#123;
        Visit(T->data);
        PreOrderTraverse(T->lchild);
        PreOrderTraverse(T->rchild);
    &#125;
&#125;
</code></pre></div>

<div class="code"><pre><code>/**
 *  中序遍历二叉树，递归算法实现
 */
void InOrderTraverse(BiTreeNode *T) &#123;
    if (T) &#123;
        InOrderTraverse(T->lchild);
        Visit(T->data);
        InOrderTraverse(T->rchild);
    &#125;
&#125;
</code></pre></div>

<div class="code"><pre><code>/**
 *  后序遍历二叉树，递归算法实现
 */
void PostOrderTraverse(BiTreeNode *T) &#123;
    if (T) &#123;
        PostOrderTraverse(T->lchild);
        PostOrderTraverse(T->rchild);
        Visit(T->data);
    &#125;
&#125;
</code></pre></div>

<h3>非递归算法</h3>

<div class="code"><pre><code>/**
 *  先序遍历二叉树，非递归算法实现
 */
void PreOrderTraverse(BiTreeNode *T) &#123;
    stack<BiTreeNode *> s;
    BiTreeNode *p = T;
    while (p || !s.empty()) &#123;
        if (p) &#123;
            Visit(p->data);
            s.push(p);
            p = p->lchild;
        &#125; else &#123;
            p = s.top();
            s.pop();
            p = p->rchild;
        &#125;
     &#125;
 &#125;
</code></pre></div>

<div class="code"><pre><code>/**
 *  中序遍历二叉树，非递归算法实现
 */
void InOrderTraverse(BiTreeNode *T) &#123;
    stack<BiTreeNode *> s;
    BiTreeNode *p = T;
    while (p || !s.empty()) &#123;
        if (p) &#123;
            s.push(p);
            p = p->lchild;
        &#125; else &#123;
            p = s.top();
            s.pop();
            Visit(p->data);
            p = p->rchild;
        &#125;
    &#125;
&#125;
</code></pre></div>

<div class="code"><pre><code>/**
 *  后续遍历二叉树，非递归算法实现
 *  当用栈来存储结点，必须分清返回根结点时，是从左子树返回的，还是从右子树返回的
 *  使用辅助指针 r，其指向最近访问过的结点（也可以在结点中增加一个标志域，记录是否已被访问）
 */
void PostOrderTraverse(BiTreeNode *T) &#123;
    stack<BiTreeNode *> s;
    BiTreeNode *p = T, *r = NULL;
    while (p || !s.empty()) &#123;
        if (p) &#123;
            // 走到最左边
            s.push(p);
            p = p->lchild;
        &#125; else &#123;
            // 向右
            p = s.top();            // 取栈顶结点
            if (p->rchild && p->rchild != r) &#123;
                // 右子树存在，且未被访问过
                p = p->rchild;      // 转向右
                s.push(p);          // 压入栈
                p = p->lchild;      // 再走到最左
            &#125; else &#123;
                // 弹出结点并访问
                p = s.top();
                s.pop();            // 将结点弹出
                Visit(p->data);     // 访问该结点
                r = p;              // 记录最近访问过的结点
                p = NULL;           // 结点访问完后，重置 p 指针
            &#125;
        &#125; // else
    &#125; // while
&#125;
</code></pre></div>

<h3>参考文献：</h3>

<p>严蔚敏, 吴伟民. 数据结构(C语言版). 清华大学出版社.</p>
<p>王道论坛. 程序员求职宝典. 电子工业出版社.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/09/16/binary-tree-traverse/" data-id="cl4h5hf39000mbdoo1sst8ks2" data-title="二叉树的遍历，伪代码实现" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-the-practice-of-management-reading-notes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/26/the-practice-of-management-reading-notes/" class="article-date">
  <time class="dt-published" datetime="2018-08-26T00:00:00.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/26/the-practice-of-management-reading-notes/">管理的实践，读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1></h1>

<p>花了好长时间才读完管理的实践这本书，不是因为内容无趣，而是因为必须专注的思考，才能体会德鲁克先生深刻的理念和见解。德鲁克先生的真知灼见和书中的系统论述，让我受益匪浅。</p>
<p>书中说到，“管理是一种实践而不是一种科学或一种专业”。同样的，虽然目前脑中有的只是书中的各种支离片段，相信随着实践和经验的增加一定会有不一样的理解。</p>
<p>本文摘录书中我觉得重要的内容。</p>
<p>本书的根本目的在于通过对管理原则、责任和实践的研究，探索如何建立有效的管理机制和制度。而衡量一种管理制度是否有效的标准就在于是否将管理者个人特征的影响降到最低。</p>
<p>贯穿本书的三条主线：<br><br>管理企业<br><br>管理管理者<br><br>管理员工和工作</p>
<p>德鲁克的三个经典提问：<br><br>我们的事业是什么<br><br>我们的事业将是什么<br><br>我们的事业究竟应该是什么</p>
<p>管理必须同时需要考虑三个方面的问题：<br><br>成果和绩效，这是企业存在的目的<br><br>在企业内部共同工作的人所形成的组织<br><br>外在社会，也就是企业的社会责任</p>
<p>概论 管理的本质</p>
<p>第1章 管理层的角色<br><br>第2章 管理层的职责<br><br>第3章 管理层面临的挑战</p>
<p>第一部分 管理企业</p>
<p>第4章 西尔斯公司的故事<br><br>第5章 企业是什么<br><br>第6章 我们的事业是什么，我们的事业应该是什么<br><br>第7章 企业的目标<br><br>第8章 今天的决策，明天的成果<br><br>第9章 生产的原则</p>
<p>第二部分 管理管理者</p>
<p>第10章 福特的故事<br><br>第11章 目标管理与自我控制<br><br>第12章 管理者必须管理<br><br>第13章 组织的精神<br><br>第14章 首席执行官与董事会<br><br>第15章 培养管理者</p>
<p>第三部分 管理的结构</p>
<p>第16章 企业需要哪一种结构<br><br>第17章 建立管理结构<br><br>第18章 大企业、小企业和成长中的企业</p>
<p>第四部分 管理员工和工作</p>
<p>第19章 IBM 的故事<br><br>第20章 雇佣整个人<br><br>第21章 人事管理是否已告彻底失败<br><br>第22章 创造巅峰绩效的组织<br><br>第23章 激励员工创造最佳绩效<br><br>第24章 经济层面<br><br>第25章 主管<br><br>第26章 专业人员</p>
<p>第五部分 当一名管理者意味着什么</p>
<p>第27章 管理者及其工作<br><br>第28章 做决策<br><br>第29章 未来的管理者<br><br>结语 管理层的责任</p>
<p>管理不仅是由现代工业体系的性质所决定的，而且是由现代企业的需要所决定的。现代工业体系必须将其生产力资源–人和物质–交托给现代企业。</p>
<p>管理体现了现代西方社会的基本信念：它体现了通过系统地组织经济资源有可能控制人的生活和信念；它体现了经济的变革能够成为争取人类进步和社会正义的强大推动力的信念。</p>
<p>管理层是专门负责赋予资源以生产力的社会机构，也是负责有组织地发展经济的机构，体现着现代社会的基本精神。</p>
<p>管理层的第一个定义是：管理层是经济器官，是工业社会所独有的经济器官。管理层的每一个行动、每一项决策和每一个考虑，都必须以经济作为首要尺度。</p>
<p>管理的三项职能：管理企业、管理管理者、管理员工和工作。</p>
<p>企业管理的技巧、能力和经验是不能被照搬运用到其它机构的。</p>
<p>管理绝不能成为一门精确的科学。</p>
<p>最终检验管理的是企业的绩效。</p>
<p>管理层的权责无论在范围或程度上都受到严格的限制。</p>
<p>管理层必须管理，而管理不只是被动的适应性行为，而是主动采取行动，促使企业获得期望的成果。</p>
<p>每个管理问题、管理决策和行动有一个共同要素，时间。为什么在管理层的工作中，时间因素显得格外重要，也格外困难？第一，经济和技术进步使得证实决策的成效和收获成果所需的时间不断延长。第二，管理者必须能兼顾现在和未来。</p>
<p>从西尔斯公司的故事中，我们得到的第一个结论是：企业是由人创造和管理的，而不是由”经济力量“创造和管理的。第二个结论是：我们不能单单从利润的角度来定义或解释企业。</p>
<p>关于企业的目的，只有一个正确而有效的定义：创造顾客。由于企业的目的是创造顾客，任何企业都有两个基本功能，而且也只有这两个基本功能：营销和创新。企业必须掌握创造财富的资源，以达到创造顾客的目的。因此企业重要的管理功能之一，就是有效地利用一切创造财富的资源，从经济角度来说，则称之为生产力。</p>
<p>有两种管理费用：生产性的管理费用——用于管理者、技术或专业人才的费用。这种费用取代了一笔至少数额相等的用于生产性或非生产性员工费用或资本支出。另一种是寄生性的或摩擦性的管理费用。这种费用不但没有提高生产力，反而降低了生产力，这是由摩擦造成的，反过来又会制造摩擦。因此我们需要的生产力观念是，一方面能将投入与产出的一切努力都加以考虑，同时又能根据与产出结果的关联性来呈现所投入的努力，而不是假定劳动力是唯一的生产性投入。</p>
<p>无论以资本取代劳动力，或以营业成本取代资本设备与人力（需要设法区分创造性和寄生性的管理费用），我们都必须评估这些因素究竟对生产力产生何种影响。有一些无形的因素对于生产力有即使不是决定性的也是巨大的影响，却无法以成本数字来衡量：时间运用、产品组合、流程组合、组织结构和各种企业活动之间的平衡。</p>
<p>“我们的事业是什么”并非由生产者决定，而是由消费者来决定；不是靠公司名称、地位或规章来定义，而是由顾客购买产品或服务时获得满足的需求来定义。因此，要回答这个问题，我们只能从外向内看，从顾客和市场的角度，来观察我们所经营的事业。</p>
<p>“我们的事业将是什么？”这个问题牵涉四个问题。首先，是市场潜力和市场趋势。其次，经济发展、流行趋势和品味的变化，或竞争对手的动作，分别会导致市场结构发生什么样的改变？第三，哪些创新将改变顾客需求、创造新需求、淘汰旧需求、创造满足顾客需求的新方式、改变顾客对价值的看法，或带给顾客更高的价值满足感？最后，今天还有哪些顾客需求无法从现有的产品和服务中获得充分满足？</p>
<p>许多公司都是在意外情况下跨入新事业，而不是有计划地朝既定方向发展。但是决定将主要的能量和资源从旧产品转移到新产品，换句话说，决定让整个事业不再只是意外的产物，必须以下列分析为基础：“我们的事业是什么？我们的事业应该是什么？”如果从市场地位、创新和生产力的角度来看，跨入新事业领域的决定符合了企业构成的基本条件的话，那么管理层的责任就是要设法获得企业必要的最低利润。</p>
<p>企业管理是在设法平衡各种需求和目标，因此需要判断力。寻找单一目标，基本上就等于在寻找一种方程式，使得判断力毫无用武之地，这是非理性的；只有缩小范围、减少替代方案、明确重点，以事实为基础，建立衡量行动与决策效益的可靠标准，才能有良好的判断。因此，由于企业的本质使然，必须建立多重目标。</p>
<p>那么，企业的目标应该是什么呢？只有一个答案：任何一个其绩效和结果对企业的生存和兴旺有着直接和举足轻重影响的领域，都需要有目标。</p>
<p>这些关键领域的目标应该能做到5点：能用简洁易懂的语言说明所有的企业现象；在实践中接受检验；能预测行为；在决策制定过程，就能加以评估；能让实际经营者分析自己的实践，并因此改善经营绩效。</p>
<p>企业应该设定绩效和成果目标的领域共有8个：包括市场地位、创新、生产力、实物和财力资源、获利能力、管理者绩效和培养管理者、员工绩效和工作态度、社会责任。</p>
<p>利润有三个目的。首先，利润衡量企业付出的努力有多少净效益以及是否健全。利润确实是企业绩效的最终检验。其次，利润是弥补继续维持事业的成本（包括更新、淘汰、市场风险和其他不确定因素）的“风险溢价”。最后，利润或者直接地以自我集资的手段，从留存的积累中提取资金，或者间接地通过提供诱因，以最适合公司目标的形式吸引新的外部资金，保障未来用于创新和发展的资金的供应。</p>
<p>为了达成目标，管理层必须设法在最近的将来（未来几年）和5年以上的长远未来之间，通过“管理支出预算”，而取得平衡。因为几乎所有影响平衡的决策都被视为会计师所谓的“管理支出”——这些支出由目前的管理决策决定，而不是由不可改变的过去决策（如资本费用）或当前企业经营上的要求（例如劳动力和原料成本）来决定。今天的“管理支出”将成为明天的利润；但也可能成为明日的亏损。</p>
<p>除了要权衡最近的将来和长远的未来之外，企业管理者也必须在各种目标之间取得平衡。要区别管理是否有效，最好的指标莫过于管理者在平衡各种目标上所显现的绩效。这项工作也没有公式可循，每一家企业都必须达到自己的平衡，而且可能在不同的时期必须达到不同的均衡状态。唯一能确定的是，平衡各种不同的企业目标并非机械化的工作，不是靠“编制预算”就可以办得到的。预算只是最后用来表达平衡决策的文件；但是决策本身有赖于良好的判断力，而健全的判断则必须基于完善的企业经营分析。企业管理者能否谨守预算，往往被视为管理能力的一大考验。但是当预算将企业各种不同的需求做了最佳调和后，能否尽力达成预算，才是检验管理能力更重要的指标。</p>
<p>企业真正的安全保障，是未来的管理者。这表示今天的管理者必须有系统地为明天的管理者做好准备。明天的管理者能够调整今天的决策以适应明天的环境，能将理性推测转变为扎实的成就，让明天的环境更适合今天所制定的决策。</p>
<p>到目前为止，我们所知的基本工业生产系统有三种：单件产品的生产系统、大规模生产系统和流程生产系统。我们也可以把它算成四种生产系统，即大规模生产系统可分为：“旧式”的大规模生产系统，也就是大规模生产同一种产品，以及“新式”的大规模生产系统，制造同一种零件，但却组装成不同的产品。</p>
<p>关于每一种系统对于管理能力的要求，有两个通则：1. 各种系统的要求不但难度有别，而且所要求的管理能力和绩效顺序也不同。从一种系统转换到另外一种系统时，管理层必须学习如何做好新工作，而不只是把旧的工作做得更好。2. 越能成功地贯彻每个系统的原则，就越容易达到系统对管理的要求。</p>
<p>管理管理者的5个要求：1. “目标管理与自我控制”。2. “为管理者的职务建立适当的结构”。3. 创造“正确的组织精神”。4. 企业必须具备治理的机构。企业需要能全面领导和制定最后决策的机制，也需要能全面检讨和评估的机制。企业既需要首席执行官，也需要董事会。5. “为管理组织建立健全的结构性原则”。</p>
<p>目标管理必须投注大量心力，并需要特殊工具。因为在企业中，管理者并不会自动自发地追求共同的目标。相反，企业在本质上包含了三种误导管理者的重要因素：管理者的专业工作；管理的层级结构；以及因愿景和工作上的差异，导致各级管理者之间产生隔阂。</p>
<p>管理者的目标应该是什么？目标从一开始就应该强调团队合作和团队成果。这些目标应该根据企业的整体目标来制定。每位管理者的目标都应该说明他对于公司所有经营目标的贡献。为了在投入的努力中求取平衡，不同领域、不同层次的管理者在制定目标时，都应该兼顾短期和长期的考虑。并且所有的目标也应该包含有形的经营目标和管理者的组织和培养，以及员工绩效、态度和社会责任等无形的目标。</p>
<p>正确的管理要求兼顾各种目标，特别是高层管理者对目标要统筹兼顾。它排斥那种普遍的、有害的经营恶习：靠“压力”和“危机”进行管理。</p>
<p>管理者应该负责让自己所管辖的单位对所属部门有所贡献，并且最后对整个企业有所贡献。他的绩效目标是向上负责，而非向下负责。每位管理者必须自行发展和设定单位的目标。当然，高层管理者仍然需要保留对目标的同意权，但是发展出这些目标则是管理者的职责所在。</p>
<p>目标管理最大的好处或许在于，管理者因此能控制自己的绩效。自我控制意味着更强烈的工作动机：想要有最好的表现，而不只是达标而已，因此会制定更高的绩效目标和更宏伟的愿景。虽然，即使有了目标管理，企业管理团队不一定就会同心协力，方向一致，但是如果要通过自我控制来管理企业，势必推行目标管理。</p>
<p>（书中所说的自我控制可以理解为，通过测评控制自己的绩效。）为了控制自己的绩效，管理者单单了解自己的目标还不够，还必须有能力针对目标，衡量自己的绩效和成果。每位管理者都应该具备评估自己绩效所需的信息，而且应该及早收到这类信息，因此才能及时修正做法，以达到预定目标。</p>
<p>有三种最常见的误用报告和程序的方式。第一，一般人普遍相信程序是道德规范的工具，其实不然。第二个误用方式是以为程序可以取代判断。第三也是最常见的误用方式是把报告和程序当作上级控制下属的工具，尤其是纯为提供信息给高级主管而交的每天例行报告更是如此。</p>
<p>企业应该把报告和程序保持在最低限度，只有当报告和程序能节省时间和人力时，才运用这项工具，并且应该尽可能简化。企业应该只采用达到关键领域的绩效所必需的报告和程序。报告和程序应该时填表者的工具，而不能用来衡量他们的绩效。</p>
<p>企业需要的管理原则是：能让个人充分发挥特长，凝聚共同的愿景和一致的努力方向，建立团队合作，调和个人目标和共同福祉的原则。目标管理和自我控制是唯一能做到这点的管理原则，能让追求共同福祉成为每位管理者的目标，以更严格、更精确和更有效的内部控制取代外部控制。管理者的工作动机不再是因为别人命令他或说服他去做某件事情，而是因为管理者的任务本身必须达到这样的目标。他不再只是听命行事，而是自己决定必须这么做。换句话说，他以自由人的身份采取行动。</p>
<p>管理者的工作应该以能够达成公司目标的任务为基础，是实质工作，能对企业的成功产生明显而且可以清楚衡量的贡献。管理者的工作范围和职权应该尽可能宽泛，凡事不能明确排除在外的事务都应该视为管理者的职责。最后，管理者应该受绩效目标的指引和控制，而不是由上司指导和控制。</p>
<p>管理单位的目标应该包括本单位对于企业的成功必须贡献的绩效与成果，应该总是把焦点放在上级的目标上，但是单位主管的目标应该包括如何协助下级主管达到目标。管理者的愿景应该总是向上看，视企业为整体，但是他同样应该向下负责，向他所领导的团队中的管理者负责。或许在有效组织管理者的工作时，基本的要求时，管理者应该明白他和下属的关系是一种责任，而不是上对下的监督。</p>
<p>目标管理告诉管理者应该做什么，通过工作的合理安排，管理者能顺利完成工作，但是组织精神却决定了管理者是否有意愿完成工作。组织精神能唤醒员工内在的奉献精神，激励他们努力付出，决定了员工究竟会全力以赴，还是敷衍了事。</p>
<p>企业必须通过5方面的实践，才能确保正确的精神贯彻于整个管理组织中：1. 必须建立很高的绩效标准，不能宽容差的或平庸的表现，而且必须根据绩效，给予奖励。2. 每个管理职位本身必须有其价值，而不只是升迁的踏板。3. 必须建立合理而公平的升迁制度。4. 管理章程中必须清楚说明谁有权制定事关管理者命运的重要决定，管理者必须有向高层申诉的途径。5. 在任命管理者的时候，必须很清楚诚实正直的品格是对管理者的绝对要求，是管理者原本就需具备的特质，不能期待他升上管理职位后才开始培养这种特质。</p>
<p>企业首席执行官必须具备3个基本特质：“思考者”、“行动者”和“抛头露面的人”。我们或许可以在一个人身上找到其中两项特质，通常很难在同一个人身上看到3个特质并存。不过，如果企业要繁荣发展，就必须在这3个重要领域中，都找到人好好负起责任。因此结论只有一个：（或许非常小的企业是个例外）即使有再妥善的安排，都不可能由个人承担企业首席执行官的所有工作，必须由好几个人共同努力，通过团队合作来完成。</p>
<p>如何组织首席执行官管理团队？第一个要求是，这必须是个“团队”，而不是“委员会”。团队没有集体责任，每个团队成员在他所负责的领域中享有最终决策权，有事情大家集思广益，但各自做决定。第二个要求是，管理团队的成员之间不能相互责难。无论是谁做的决定，都代表整个管理团队的决定。这并不表示管理团队不需要有一位队长。相反，队长的角色非常重要，而且一定会有某个人凭着才干和道德权威脱颖而出。</p>
<p>培养未来管理者的第一个原则是必须培养所有的管理者。第二个原则是，培养管理者必须是动态的活动，绝不能只把目标放在今天——取代今天的主管、他们的工作或他们的资格，而必须总是把焦点放在明天的需求上。（不能根据机械化的轮调制度进行静态的人事更迭）</p>
<p>在讨论组织结构的时候，必须同时考虑需要的是哪一种结构，以及应该如何建立这种结构。组织本身不是目的，而是达到经营绩效和成果的手段。组织结构是不可或缺的工具；错误的结构会严重伤害，甚至摧毁企业经营绩效。</p>
<p>任何针对组织的分析，都不应该从讨论结构开始，而必须先做经营分析。有3种特殊方法可以找出达到经营目标所需的结构：活动分析、决策分析和关系分析。</p>
<p>不去分析企业实际需要的活动，而只以典型的企业职能（如制造业的典型职能就包括生产、营销、工程、会计、采购和人事）取而代之，反映了危险的怠惰心理，结果将事倍功半。因为只有经过完整细密的活动分析，才能理清必须完成哪些工作，应该把哪些工作归为一类，以及每一项活动在组织结构中有何重要性。</p>
<p>有四种基本特性决定了企业决策的本质。第一，决策的未来性。第二，这个决策对公司其他职能、其他领域或企业整体的影响有多大。第三，决策的性质是由其中包含多少质的因素来决定：例如基本行为准则、伦理价值、社会和政治信念等。最后，我们可以根据究竟这是经常性决策，还是偶尔为之的特殊决策来归类。</p>
<p>关系分析。负责某项活动的管理者必须和谁合作，他必须对负责其他活动的管理者有什么贡献，反之，这些管理者又必须对他有什么贡献？包括，上对下的关系分析，下对上的关系分析，横向关系分析。</p>
<p>建立管理结构时，第一个要考虑的是：这个结构必须满足哪些条件。这一问题的主要答案有三个：1. 管理结构在组织上必须以绩效为目标。2. 组织结构必须尽可能包含最少的管理层级，设计最便捷的指挥链。3. 组织结构必须能培育和检验未来的高层管理者。为了满足这些要求，组织结构必须采取以下原则之一：企业必须依照联邦分权制的原则，尽可能整合所有的活动，将企业活动组织成自主管理的产品事业，拥有自己的市场和产品，同时也自负盈亏。不可能采用这种原则的组织，则必须采取职能分权制的原则，设立整合的单位，为企业流程中最主要的阶段，负起最大的责任。联邦分权制和职能分权制这两个原则互补而非相互竞争。</p>
<p>无论事业单位的规模是大是小，多么独立自主或很多限制，如果要成功地实施联邦分权制，应该遵守五个规则：1. 任何联邦式组织都需要强大的分布和强有力的中央。2. 采取联邦分权制的单位规模必须大到足以支撑所需要的管理结构。3. 每个联邦分权制的单位应该都富有成长的潜力。4. 管理者在工作上应该有充分的发挥空间和挑战。5. 联邦单位应该并行，每个单位有自己的任务、市场和产品，同时彼此竞争，和通用汽车或福特汽车的汽车事业部一样。</p>
<p>职能性组织存在许多弱点。职能性组织越接近联邦分权制，则效益越高，问题越少。</p>
<p>无论实施联邦或职能分权制，都必须在企业上上下下建立共同的公民意识，在多元中保存一致性。无论是因为职能性组织的派系斗争还是产品事业部狭隘的本位主义，要建立共同的公民意识，保持向心力，管理层可以采取如下方法。第一种方法关系到高层保留给自己的决策权。必须有某种“共同福祉条款”，将影响企业整体及未来长期利益的重要决策权保留给中央主管机关，因此中央有权基于整体利益，而驳回地方单位野心勃勃的计划。第二种方法公司应该跨越部门和单位的界限，有系统地提拔管理人才。</p>
<p>组织不健全的一个明显症状是管理层级不断增加——显示缺乏目标或目标混乱，不能撤换表现不佳的员工，过度中央集权，或缺乏适当的活动分析。同样明显的迹象是，员工喜欢“通过渠道沟通”，而不直接去找掌握了信息、有想法或应该被告知目前状况的人沟通。管理层年龄结构失衡问题。</p>
<p>人力资源是所有经济资源中，使用效率最低的资源。提升经济绩效的最大契机完全在于企业能否提升员工的工作效能，这种说法在美国管理界几乎已经变成老生常谈了。企业能否提高经营绩效，完全要看能否促使员工提高工作绩效。因此，管理员工和工作，是管理的基本功能之一。</p>
<p>从工程观点来看，企业应该先考虑人力资源最大的长处和弱点，并据此建立最适合人力资源特性和限制的工作组织。人力资源有一种其他资源所没有的特性：具有协调、整合、判断和想象的能力。事实上，这是人力资源唯一的特殊优越性；在其他方面，无论是体力、手艺或感知能力上，机器都胜过人力。人具有许多独一无二的特质。和其他资源不同的是，人对于自己要不要工作，握有绝对的自主权。专制的领导者常常忘了这点。杀死抵抗分子无法完成工作，因此，应该设法改变工作动机。</p>
<p>工作的组织方式必须设法让个人所有的长处、进取心、责任感和能力，都能对群体的绩效和优势有所贡献。这是组织的首要原则，事实上，这也是组织开宗明义的目的。人力资源和其他资源不同之处在于，一个人的“发展”无法靠外力来完成，不是找到更好的方法来运用既有特性这么简单。人力资源发展代表的是个人的成长，而个人的成长往往必须从内在产生。因此，管理者的工作是鼓励并引导个人的成长，否则就无法充分运用人力资源的特长。</p>
<p>企业对员工的要求。企业期望员工不只是被动接受劳动力工作，而必须主动承担达成经营绩效的责任。企业对员工还必须有第二个要求：员工必须愿意接受改变。创新是企业的必要功能，也是企业的重要社会责任。然而，员工必须愿意改变他们的工作、习惯和群体关系，企业才能不断创新。</p>
<p>员工对企业的要求。许多人都误用“公平的报酬”这句话来说明员工对企业的要求。对企业有所要求的员工是完整的个人，而不只是个经济单位。他是基于一个人、一位公民的身份，来提出超越经济报酬的要求。他要求能够通过工作，在职位上发挥所长，建立自己的地位；他要求企业履行社会对个人的承诺——通过公平的升迁机会，实现社会正义；他要求从事有意义的严肃工作。此外，员工对企业最重要的要求还包括：建立高绩效标准、具备组织和管理工作的高度能力，以及能明确表达对于良好工作表现的关注。尤其在自由社会中，员工既身而为人，同时也是社会公民，自然对企业带来限制。要求员工对企业绝对忠诚，就好像企业承诺对员工负起百分之百的责任一样，都是不对的。</p>
<p>基本原则：必须先假定每个人都想工作，不能假定他们没有工作意愿，这和我们对人性的理解不符。管理层的任务是激发员工的工作动机和参与感，唤起他们的工作欲望。</p>
<p>低层和高层工作或低薪和高薪的工作，主要差别应该在于例行、重复性事务与需要技巧或判断的工作各占多少比例，要求具备的技能和判断力有多高，以及承担的职责有什么不同，也就是说，如果缺乏必要的技能或判断错误的话，会对组织整体绩效产生多大的影响。</p>
<p>创造巅峰绩效的组织。装配线是无效率的设计。针对机械性工作，以机械化为原则；针对人的工作，则以整合为原则。</p>
<p>在管理员工和工作时，最重要的任务之一是把安排员工职务视为持续性且系统化的努力。不能在新人刚来时就决定，而必须等到他花时间了解工作，公司也对他有更多的了解之后，才真正指派他工作，而且也不是一旦做了决定，就绝不更改，必须不断检讨工作分派是否合适。</p>
<p>激励员工创造最佳绩效。唯一有效的方法是加强员工的责任感，而非满意度。我们可以通过四种方式来造就负责任的员工，这四种方式包括：慎重安排员工职务、设定高绩效标准、提供员工自我控制所需的信息、提供员工参与的机会以培养管理者的愿景。</p>
<p>要根据目标来衡量绩效，需要有充足的信息。问题不在于员工需要多少信息，而在于企业为了自身利益，必须让员工了解多少信息。管理者应该尽量提供信息——不是因为员工要求看到这些数据，而是因为这么做才符合公司最大利益。</p>
<p>当员工拥有管理者的愿景时，也就是说，如果员工能站在管理者的角度来看待企业，认为自己的绩效将影响企业的兴衰存亡，那么他才会承担起达到最高绩效的责任。</p>
<p>企业将薪资看作成本，要求薪资必须有弹性，而员工将薪资看作收入，要求薪资稳定，两者之间有很大的分歧。只通过可预测的薪资和雇佣计划，才能解决这个冲突。我们需要的不是长生不老的保证——工会传统的“保障年薪”诉求。我们需要的是寿险计划，这是企业做得到的。</p>
<p>对自由经济危害最大的莫过于员工对利润的敌意。工作才是员工在企业中真正拥有的东西，利润分享或股权分享都不是核心，只是附加品而已。</p>
<p>主管需要什么。1. 为自己的活动制定明确的目标，而且目标必须直接聚焦于企业的经营目标。2. 企业必须提供主管充足的升迁机会，并且根据明确的绩效标准，制定合理的升迁制度。3. 主管需要拥有管理者的地位。</p>
<p>主管的职责是什么。1. 主管工作必须是真正的管理工作，主管必须担负起大部分的管理责任。2. 主管必须能够控制履行职责时所需的活动，也必须有充足的人力来处理相关事务。3. 我们必须设法扭转趋势，不再削减主管的权限。4. 主管的单位规模应该要比目前大。</p>
<p>如果有人认为，我表面上似乎要把主管工作变得更容易管理，也更有意义，但实际上是要“废除”主管职务，那么我的回答是，我的本意确实是如此。当企业希望促使员工达到最高绩效时，他们需要的是管理者，而非主管。</p>
<p>现代企业至少需要3种类型的工作人员：企业需要管理者，也需要普通工人，无论他们是技术或非技术性员工，从事体力劳动或事务性工作。最后，企业越来越需要个体的专业贡献者。</p>
<p>管理者必须为成果负责，因此他必须为别人的工作负责。个体的专业贡献者无论采取单独工作方式，或是团队的一份子，都为自己的贡献负责。由于管理者必须为单位的工作成果负责，因此他必须有权安排、调动单位的员工，并指导他们工作；他必须规划他们的职务内容，将他们在工作上付出的心力组织起来，把他们整合为一个团队，同时评估他们的工作成果。个别的贡献者也为成果负责，但只为自己的工作成果负责。只有当其他人了解他的工作成果，并且能运用他的工作成果时，他的工作才能发挥功效。这意味着个别贡献者对于其他人也有应负的权责，但是这些权责不同于管理者的权责，反而比较像是老师的权责。</p>
<p>第二个不同之处在于专业人员的工作和企业的绩效目标及经营成果之间的关系。设定职务目标时，如果直接以企业的经营目标为依据，那么这必然是管理性职务，可以直接依照这个职务对企业成功的贡献来衡量其绩效。只要依照正确的结构原则来组织职务内容，就能符合组织精神的要求。但是如果无法直接从企业经营目标发展出职务的目标，这就不是一项管理性的职务，它的目标可能是专业上的目标，而不是以企业成功为目的，绩效衡量时根据的是专业标准，而非对企业经营绩效和成果有多少贡献。</p>
<p>究竟专业与非专业、技术与非技术员工真正的差别何在呢？身为专业人员，他的工作内容、工作标准、目标和愿景都完全要根据某个专业的标准、目标和愿景来制定，换句话说，主要取决于企业外部的因素。专业人员必须自行决定他的工作内容为何，做到什么地步才称得上表现优异，别人无法替他决定他应该做什么，以及工作标准为何。</p>
<p>当然，这些界限都很模糊。许多专业人员十分近似于管理者；许多专业人员则比较像非专业性的员工，也就是单纯的技术人员。</p>
<p>要让专业人员在企业中发挥效能和生产力，必须满足五个特殊需求：他必须是专业人员，但也必须对企业有所贡献，而且知道自己有何贡献；他必须享有专业人员和个别贡献者的升迁机会；当他改善绩效和提高个人贡献时，企业必须提供金钱上的奖励；他的职务必须属于专业工作；他需要在企业内部和更广大的社区中获得专业上的肯定。</p>
<p>管理者有两项特殊任务，企业中其他人都不需负担这两项任务，而且凡是必须承担这两项任务的人都是管理者。第一项任务是创造出大于各部分总和的真正整体，创造出有生产力的实体，而且其产出将大于所有投入资源的总和。第二项任务是协调每个决策和行动的长远的需求和眼前的需求。</p>
<p>管理者的工作中包含了5项基本活动。1. 管理者设定目标，决定目标应该是什么，也决定应该采取哪些行动，以达到目标。2. 管理者从事组织的工作。3. 管理者还必须激励员工，和员工沟通。4. 管理者必须为工作建立衡量标准。5. 管理者必须培养人才。</p>
<p>管理者有一个特殊工具：信息。管理者不“操纵”人，而是激励、引导、组织他人做好自己的工作。管理者如果不能通过书写和口头文字或明确的数据来激励部属，就不可能成为成功的管理者。</p>
<p>懂得善用时间的管理者通过良好的规划，达成绩效。他们愿意先思考，再行动，花很多时间彻底思考应该设定目标的领域，花更多时间有系统地思考如何解决一再出现的老问题。大多数的管理者都要花很多时间来评估部属的工作绩效与工作品质。然而善用时间的人却不会如此，他们每年对下属做一次系统化的评估。善用时间的人也不会花大量时间修改产品的工程设计。善用时间的管理者花在和上司沟通的时间远多于和下属沟通的时间。善用时间的管理者也花很多时间思考上司的问题，以及思考他对上司、对整个企业的成功可以有什么贡献。</p>
<p>管理者培养部属时，方向是否正确，能否协助部属成才为更重要、更丰富的人，将直接决定管理者自己能否成长、发展，还是逐渐颓废；内涵越来越丰富，还是每况愈下；不断进步，还是日趋堕落。管理者能从管理工作中，学到一些技巧，例如主持会议的技巧或面谈的技巧。他可以规划一些有助于人才培育的做法——例如管理者及部属的关系结构、升迁制度、组织的奖励措施等方面。管理者的基本品质，诚实正直的品格。</p>
<p>我们只能以一个人的功能和企业期望他发挥的贡献来定义他是不是管理者。而管理者有别于其他员工的独特功能乃是教育的功能。企业期望他发挥的独特贡献，则是赋予他人达成绩效的能力和愿景。最后，是道德责任和愿景决定了一个人究竟算不算管理者。</p>
<p>大多数的战术决策都更复杂，也更重要，但通常总是单向思考，也就是说：在既定的情况和明确的要求下做的决策。唯一的问题只是要找到最符合经济效益的方式，来运用已知的资源就好。但是真正重要的决策，都是战略性决策，必须设法了解情势或改变情势，找出可用的资源或应该采用的资源。这些都属于管理决策。任何管理者都必须制定这类战略性决策，管理者的层级越高，则需要制定的战略性决策就越多。</p>
<p>决策包含了5个不同的阶段：界定问题、分析问题、制定可行的替代方案、寻找最佳的解决方案、把决策转化为有效的行动。</p>
<h3>参考文献：</h3>

<p>彼得.德鲁克. 管理的实践.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/08/26/the-practice-of-management-reading-notes/" data-id="cl4h5hf4i001cbdoo79fz9tej" data-title="管理的实践，读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-image-and-graphics-best-practices" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/22/image-and-graphics-best-practices/" class="article-date">
  <time class="dt-published" datetime="2018-08-22T00:00:00.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/22/image-and-graphics-best-practices/">iOS 图像解码和最佳实践</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 class="title"></h1>

<h2>前言</h2>

<p>最近组内同事做了 iOS 图像解码的分享。针对不太清楚的问题，又做了些调研，梳理如下。</p>
<h2 id="section_1">1. 三种 Buffer 和解码</h2>

<p>Buffer 表示一片连续的内存空间。通常，我们说的 Buffer 是指一系列内部结构相同、大小相同的元素组成的内存区域。</p>
<p>有三种 Buffer：Data Buffer、Image Buffer、Frame Buffer。</p>
<p>Data Buffer 是存储在内存中的原始数据，图像可以使用不同的格式保存，如 jpg、png。Data Buffer 的信息不能用来描述图像的像素信息。</p>
<p>Image Buffer 是图像在内存中的存在方式，其中每个元素描述了一个像素点。Image Buffer 的大小和图像的大小成正比。</p>
<p>Frame Buffer 和 Image Buffer 内容相同，不过其存储在 vRAM（video RAM）中，而 Image Buffer 存储在 RAM 中。</p>
<p>解码就是从 Data Buffer 生成 Image Buffer 的过程。Image Buffer 会上传到 GPU 成为 Frame Buffer，GPU 以每秒60次的速度使用 Frame Buffer 更新屏幕。</p>
<p>下图描述了图像从文件到渲染到屏幕上的流程。</p>
<!-- <p class="post-image">
    <img src="/resources/figures/2018-08-22-image-rendering-pipeline.png" alt="图像渲染流程" width="90%">
</p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-08-22-image-rendering-pipeline.png"></p>
<p class="post-image-title">图像渲染流程</p>

<h2 id="section_2">2. UIImage 和 UIImageView</h2>

<p>UIImage 和 UIImageView 的角色类似于 MVC 架构模式中的数据和视图，如下图所示。</p>
<!-- <p class="post-image">
    <img src="/resources/figures/2018-08-22-uiimage-uiimageview.png" alt="UIImage 和 UIImageView" width="90%">
</p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-08-22-uiimage-uiimageview.png"></p>
<p class="post-image-title">UIImage 和 UIImageView 的角色</p>

<p>UIImage 是 iOS 中处理图像的高级类。创建一个 UIImage 实例只会加载 Data Buffer，将图像显示到屏幕上才会触发解码，也就是 Data Buffer 解码为 Image Buffer。Image Buffer 也关联在 UIImage 上。</p>
<p>UIImage 关联的图像是否已解码对外部是透明的（如本文最后的 Instruments 截图，调用栈中都是系统函数），没有办法判断。</p>
<h2 id="section_3">3. 图像解码</h2>

<p>上面说到，UIImage 关联的图像是否已解码对外部是透明的，但是有许多操作会触发图像的解码，下面是一些例子。</p>
<h3>隐式解码</h3>

<p>将图像显示到屏幕上会触发隐式解码。（必须同时满足图像被设置到 UIImageView 中、UIImageView 添加到视图，才会触发图像解码。)</p>
<div class="code"><pre><code>UIImageView *imageView = [[UIImageView alloc] init];
[self.view addSubview:imageView];
[imageView setImage:image];
</code></pre></div>

<p></p>

<h3>Core Graphics</h3>

<p>手动绘制图像能完成图像解码，下面代码中的 newImage 实例的图像已完成解码。</p>
<div class="code"><pre><code>UIGraphicsBeginImageContextWithOptions(image.size, YES, [UIScreen mainScreen].scale);
[image drawAtPoint:CGPointZero];
UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
</code></pre></div>

<p>下面的代码片段截取自 <a href="https://github.com/ibireme/YYKit.git" target="_blank">YYKit</a>，其中 newImage 实例的图像已完成解码。在测试工程中，该代码比上面直接绘制代码快约7倍。</p>
<div class="code"><pre><code>size_t width = CGImageGetWidth(imageRef);
size_t height = CGImageGetHeight(imageRef);
CGColorSpaceRef space = CGImageGetColorSpace(imageRef);
size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);
size_t bitsPerPixel = CGImageGetBitsPerPixel(imageRef);
size_t bytesPerRow = CGImageGetBytesPerRow(imageRef);
CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);

<p>CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);<br>CFDataRef data = CGDataProviderCopyData(dataProvider);      // 主要耗时操作（解码）</p>
<p>CGDataProviderRef newProvider = CGDataProviderCreateWithCFData(data);<br>CFRelease(data);</p>
<p>CGImageRef newImageRef = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, bitmapInfo, newProvider, NULL, false, kCGRenderingIntentDefault);<br>UIImage *newImage = [[UIImage alloc] initWithCGImage:newImageRef];<br>CGImageRelease(newImageRef);<br>CFRelease(newProvider);<br></code></pre></div></p>
<h3>Image I/O</h3>

<p>Image I/O 提供了多种处理图像的接口，但是我并没有找到一个可以直观的触发图像解码的实现方案。（简单的使用 CGImageSourceCreateWith… / CGImageSourceCreateImageAtIndex 这对函数并不会触发解码。）（下文中引用的 WWDC 提供的代码段算是一种解码的方案。）</p>
<h2 id="section_4">4. 最佳实践</h2>

<p>内存和 CPU 是 App 运行最宝贵的资源，我们处理和使用图像从减少内存占用和优化 CPU 使用入手。下面提供一些优化方案。</p>
<h3>减少内存占用</h3>

<p>大的图像会占用较多的内存资源，解码和传输到 GPU 也会耗费较多时间。实际需要显示的图像尺寸可能并不是很大，如果能将大图缩小，便能达到优化的目的。</p>
<p>下面的代码片段来自 WWDC 2018，功能是缩小图像并解码。原始代码为 Swift，这里转成了 Objective-C。</p>
<div class="code"><pre><code>// 大图缩小为显示尺寸的图
- (UIImage *)downsampleImageAt:(NSURL *)imageURL to:(CGSize)pointSize scale:(CGFloat)scale &#123;
    // 利用图像文件地址创建 image source
    NSDictionary *imageSourceOptions =
  @&#123;
    (__bridge NSString *)kCGImageSourceShouldCache: @NO // 原始图像不要解码
    &#125;;
    CGImageSourceRef imageSource =
    CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, (__bridge CFDictionaryRef)imageSourceOptions);

<pre><code>// 下采样
CGFloat maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale;
NSDictionary *downsampleOptions =
@&#123;
  (__bridge NSString *)kCGImageSourceCreateThumbnailFromImageAlways: @YES,
  (__bridge NSString *)kCGImageSourceShouldCacheImmediately: @YES,  // 缩小图像的同时进行解码
  (__bridge NSString *)kCGImageSourceCreateThumbnailWithTransform: @YES,
  (__bridge NSString *)kCGImageSourceThumbnailMaxPixelSize: @(maxDimensionInPixels)
   &#125;;
CGImageRef downsampledImage =
CGImageSourceCreateThumbnailAtIndex(imageSource, 0, (__bridge CFDictionaryRef)downsampleOptions);
UIImage *image = [[UIImage alloc] initWithCGImage:downsampledImage];
CGImageRelease(downsampledImage);
CFRelease(imageSource);

return image;
</code></pre>
<p>}<br></code></pre></div></p>
<h3>优化 CPU 使用</h3>

<p>CPU 使用的优化我们考虑的是，利用设备的多核芯片（多线程）和采用预处理策略。</p>
<p>值得关注的 CPU 计算工作是，Data Buffer 转 Image Buffer 这一过程，也就是解码过程。在一个测试工程中，大量的设置了图像的 UIImageView 被显示到屏幕上，图像解码是性能瓶颈。如下图所示。</p>
<!-- <p class="post-image">
    <img src="/resources/figures/2018-08-22-time-profiler-applejpeg-decode-image-all.png" alt="" width="100%">
</p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-08-22-time-profiler-applejpeg-decode-image-all.png"></p>
<p>预处理本身并没有减少 CPU 的工作量，但是在 CPU 空闲时提前完成图像解码，能间接达到优化用户体验的效果。</p>
<h3>参考文献：</h3>

<p>WWDC2018. <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank">Image and Graphics Best Practices</a></p>
<p>Luke Parham. <a href="http://www.lukeparham.com/blog/2018/3/14/decoding-jpegs-with-the-best" target="_blank">JPEG Decoding with the Best</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/08/22/image-and-graphics-best-practices/" data-id="cl4h5hf38000lbdoodu05cy0n" data-title="iOS 图像解码和最佳实践" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-how-to-choose-opensource-liscence" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/27/how-to-choose-opensource-liscence/" class="article-date">
  <time class="dt-published" datetime="2018-06-27T00:00:00.000Z" itemprop="datePublished">2018-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/27/how-to-choose-opensource-liscence/">如何选择开源许可证？（转）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1></h1>

<p>原文链接，<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank">阮一峰的网络日志-如何选择开源许可证</a>。</p>
<p>下图说明了如何选择一个合适的开源许可证书。</p>
<!-- <p class="post-image">
    <img src="/resources/figures/2018-06-27-opensource-liscences.png" alt="opensource liscences" width="100%">
</p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-06-27-opensource-liscences.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/06/27/how-to-choose-opensource-liscence/" data-id="cl4h5hf37000kbdooho4jdvp1" data-title="如何选择开源许可证？（转）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-event-dispatch-and-dom-event-flow-translation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/19/event-dispatch-and-dom-event-flow-translation/" class="article-date">
  <time class="dt-published" datetime="2018-06-19T00:00:00.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/19/event-dispatch-and-dom-event-flow-translation/">事件分发和 DOM 事件流（译）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>原文链接，<a href="https://www.w3.org/TR/uievents/#event-flow" target="_blank">Event dispatch and DOM event flow</a>。</p>
<p>本文讲述事件分发机制和事件在 DOM 树上的传播行为。Web 应用使用 <code>dispatchEvent()</code> 方法分发事件对象，事件对象遵循 DOM 事件流，在 DOM 树上传播。</p>
<!-- <p class="post-image"><img src="/resources/figures/2018-06-19-eventflow.svg" alt="eventflow" width="90%"></p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-06-19-eventflow.svg"></p>
<p class="post-image-title">事件分发示意图</p>

<p>事件对象会被分发给事件目标（event target），事件目标是指最终被选中的响应事件的对象，可以从事件的 <code>target</code> 属性获取。</p>
<p>在事件分发开始之前，事件对象的传播路径（propagation path）必须首先确定下来。</p>
<p>传播路径（propagation path）是一个由当前事件目标（current event targets）组成的有序列表，事件会依次经过这些事件目标。当前事件目标可能是事件目标本身（event target），或者事件目标的祖先节点。事件不断传播时，当前事件目标也在不断发生改变。当前事件目标可以从事件的 <code>currentTarget</code> 属性获取。</p>
<p>传播路径列表中的最后一个条目即为事件目标。传播路径还反映了文档的分层树状结构。在事件目标之前的条目被称为祖先，紧接着事件目标之前的条目被称为父亲。</p>
<p>传播路径确定下来后，事件在传播的过程中会经过一个或多个阶段。事件阶段一共有三个：捕获阶段（capture phase）、目标阶段（target phase）、冒泡阶段（bubble phase）。如果事件不支持某个阶段，或者事件传播被阻止，那么这个阶段会被跳过。比如，如果事件的 <code>bubbles</code> 属性被设为 <code>false</code>，那么冒泡阶段会被跳过。如果事件的 <code>stopPropagation()</code> 方法在分发之前被调用，那么所有的阶段都会被跳过。</p>
<p>捕获阶段（capture phase）：在这个阶段，事件对象沿着事件目标的祖先节点传播，从 <code>window</code> 到事件目标的父节点。</p>
<p>目标阶段（target phase）：这个阶段也被称为 <code>at-target phase</code>，表明事件对象到达了事件目标。如果事件表明不再进行冒泡，那么事件对象在完成该阶段后便停止传播。</p>
<p>冒泡阶段（bubble phase）：在这个阶段，事件对象沿着事件目标的祖先节点逆向传播，从事件目标的父节点到 <code>window</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/06/19/event-dispatch-and-dom-event-flow-translation/" data-id="cl4h5hf36000jbdoocpy44fib" data-title="事件分发和 DOM 事件流（译）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pod-trunk-push-without-validation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/12/pod-trunk-push-without-validation/" class="article-date">
  <time class="dt-published" datetime="2018-05-12T00:00:00.000Z" itemprop="datePublished">2018-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/12/pod-trunk-push-without-validation/">如何在验证失败的情况下发布 Pod</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 CocoaPods 发布 Pod 的最后一步是执行 <code>pod trunk push</code> 命令，pod-trunk 首先会对你创建的 Pod 进行验证，验证通过才允许上传。</p>
<p>有时，希望在 Pod 验证失败的情况下也能够上传，关于这种做法是否合理 <a href="https://github.com/CocoaPods/CocoaPods/issues/5801" target="_blank">这里</a> 有相关讨论。讨论中 <a href="https://github.com/mxcl" target="_blank">@mxcl</a> 给出了一种绕过发布前验证的方法，如下文所述。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>pod 命令使用 Ruby 写成，使用解释型语言的好处是我们可以方便的修改命令的逻辑。只要找到目标代码，注释掉验证 Pod 的逻辑便能达到目的。</p>
<p>首先执行 <code>gem env</code>，如下变量给出了 Ruby 库安装的位置。</p>
<div class="code"><pre><code>  - INSTALLATION DIRECTORY: /usr/local/lib/ruby/gems/2.4.0
</code></pre></div>

<p>当前，<code>pod trunk push</code> 命令文件对于 Ruby 库根目录的相对位置是 <code>gems/cocoapods-trunk-1.3.0/lib/pod/command/trunk/push.rb</code>，只要注释掉如下一行代码即可。</p>
<div class="code"><pre><code>def run
    update_master_repo
    # validate_podspec  # 删除验证逻辑
    status, json = push_to_trunk
    update_master_repo

<pre><code># ...
</code></pre>
<p>end<br></code></pre></div></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/05/12/pod-trunk-push-without-validation/" data-id="cl4h5hf35000ibdooejqv05ag" data-title="如何在验证失败的情况下发布 Pod" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-callmethodwithcompletionblock-memory-speculating" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/08/callmethodwithcompletionblock-memory-speculating/" class="article-date">
  <time class="dt-published" datetime="2018-02-08T00:00:00.000Z" itemprop="datePublished">2018-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/08/callmethodwithcompletionblock-memory-speculating/">callMethodWithCompletionBlock&amp;#58; 中 Block 的内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>开发中不时会遇到 <code>[obj callMethodWithCompletionBlock:^&#123; [obj doSomething] &#125;]</code> 这种写法。调用一个 OC 实例对象的带有 block 回调的方法，并且 block 实现又引用了该实例变量。写到这里经常会犹豫，要不要弱引用该实例变量，会不会造成循环引用。本文通过 Demo 演示了相关的几种情况，并对内存管理加以分析。</p>
<p>本文的讨论都是基于 ARC，并且一般性的 block 内存管理说明可以参考<a href="/2018/09/30/block.html">这篇文章</a>。</p>
<h2>Demo 1</h2>

<div class="code"><pre><code>@interface CustomUIView : UIView
@end
@implementation CustomUIView
- (void)doSomeThing:(void(^)(void))block &#123;
    block();
&#125;
- (void)emptyMethod &#123;&#125;
- (void)dealloc &#123;
    NSLog(@"CustomUIView dealloc");
&#125;
@end

<p>@interface ViewController ()<br>@end<br>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad &#123;<br>  [super viewDidLoad];<br>  CustomUIView *customView = [[CustomUIView alloc] init];<br>  [customView doSomeThing:^&#123;<pre><code>  [customView emptyMethod];
</code></pre>
  }];<br>}<br>@end<br></code></pre></div></li>
</ul>
<p>运行结果：</p>
<div class="code"><pre><code>2018-02-08 15:56:53.638344+0800 Test[41287:2545568] CustomUIView dealloc
</code></pre></div>

<p>Demo 1 演示的即是本文开头说的情况，运行结果显示没有产生循环引用，customView 正常释放。</p>
<p>结论：block 引用了 customView，但是 customView 没有引用 block。见 Demo 2。</p>
<h2>Demo 2</h2>

<div class="code"><pre><code>@interface CustomUIView0 : UIView
@end
@implementation CustomUIView0
- (void)emptyMethod &#123;&#125;
- (void)dealloc &#123;
    NSLog(@"CustomUIView0 dealloc");
&#125;
@end

<p>@interface CustomUIView : UIView<br>@end<br>@implementation CustomUIView</p>
<ul>
<li>(void)doSomeThing:(void(^)(void))block &#123;<br>  block();<br>&#125;</li>
<li>(void)emptyMethod &#123;&#125;</li>
<li>(void)dealloc &#123;<br>  NSLog(@”CustomUIView dealloc”);<br>&#125;<br>@end</li>
</ul>
<p>@interface ViewController ()<br>@property (strong, nonatomic) CustomUIView *customView;<br>@end<br>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad &#123;<br>  [super viewDidLoad];<br>  CustomUIView0 *view0 = [[CustomUIView0 alloc] init];<br>  self.customView = [[CustomUIView alloc] init];<br>  [self.customView doSomeThing:^&#123;<pre><code>  [view0 emptyMethod];
</code></pre>
  }];<br>}<br>@end<br></code></pre></div></li>
</ul>
<p>运行结果：</p>
<div class="code"><pre><code>2018-02-08 15:58:54.662221+0800 Test[41318:2553382] CustomUIView0 dealloc
</code></pre></div>

<p>该示例中 customView 被强引用，不会释放。因为 block 引用了 view0，如果 customView 引用 block，那么 view0 便不会被释放。但是实际上 view0 正常释放，说明 Demo 1 的结论是正确的。</p>
<h2>Demo 3</h2>

<div class="code"><pre><code>@interface CustomUIView0 : UIView
@end
@implementation CustomUIView0
- (void)emptyMethod &#123;&#125;
- (void)dealloc &#123;
    NSLog(@"CustomUIView0 dealloc");
&#125;
@end

<p>@interface CustomUIView : UIView<br>@property (strong, nonatomic) void(^strongBlock)(void);<br>@end<br>@implementation CustomUIView</p>
<ul>
<li>(void)doSomeThing:(void(^)(void))block &#123;<br>  self.strongBlock = block;<br>  block();<br>&#125;</li>
<li>(void)emptyMethod &#123;&#125;</li>
<li>(void)dealloc &#123;<br>  NSLog(@”CustomUIView dealloc”);<br>&#125;<br>@end</li>
</ul>
<p>@interface ViewController ()<br>@property (strong, nonatomic) CustomUIView *customView;<br>@end<br>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad &#123;<br>  [super viewDidLoad];<br>  CustomUIView0 *view0 = [[CustomUIView0 alloc] init];<br>  self.customView = [[CustomUIView alloc] init];<br>  [self.customView doSomeThing:^&#123;<pre><code>  [view0 emptyMethod];
</code></pre>
  }];<br>}<br>@end<br></code></pre></div></li>
</ul>
<p>Demo 3 与 Demo 2 的区别是 CustomUIView 中强引用了 block，此时 view0 不会释放，存在 self -&gt; customView -&gt; block -&gt; view0 这样的强引用关系。</p>
<p>这样的强引用关系是单向的，只要打破其中一个环节便能释放，比如作如下修改：</p>
<div class="code"><pre><code>    CustomUIView0 *view0 = [[CustomUIView0 alloc] init];
    CustomUIView *customView = [[CustomUIView alloc] init];
    [customView doSomeThing:^&#123;
        [view0 emptyMethod];
    &#125;];
</code></pre></div>

<p>运行结果：</p>
<div class="code"><pre><code>2018-02-08 16:48:27.802266+0800 Test[41900:2865267] CustomUIView dealloc
2018-02-08 16:48:27.802428+0800 Test[41900:2865267] CustomUIView0 dealloc
</code></pre></div>

<p>此时 customView 成为局部变量，上下文结束便释放。被引用的 block 和 view0 也会依次释放。</p>
<h2>Demo 4</h2>

<div class="code"><pre><code>@interface CustomUIView : UIView
@property (strong, nonatomic) void(^strongBlock)(void);
@end
@implementation CustomUIView
- (void)doSomeThing:(void(^)(void))block &#123;
    self.strongBlock = block;
    block();
&#125;
- (void)emptyMethod &#123;&#125;
- (void)dealloc &#123;
    NSLog(@"CustomUIView dealloc");
&#125;
@end

<p>@interface ViewController ()<br>@property (strong, nonatomic) CustomUIView *customView;<br>@end<br>@implementation ViewController</p>
<ul>
<li>(void)viewDidLoad &#123;<br>  [super viewDidLoad];<br>  CustomUIView *customView = [[CustomUIView alloc] init];<br>  [customView doSomeThing:^&#123;<pre><code>  [customView emptyMethod];
</code></pre>
  }];<br>}<br>@end<br></code></pre></div></li>
</ul>
<p>最后，我们来看一个会产生循环引用的例子。Demo 4 和 Demo 1 的区别是 CustomUIView 中强引用了 block。此时存在 customView -&gt; block -&gt; customView 这样的循环引用，除非显式打破这个环状引用（比如 customView 中有逻辑能解除对 block 的引用），否则便产生了内存泄漏。</p>
<!-- <p class="post-image"><img src="/resources/figures/2018-02-08-Memory-Leak.png" alt="" width="70%"></p> -->

<p><img src="https://media.githubusercontent.com/media/rob2468/rob2468.github.io/master/images/2018-02-08-Memory-Leak.png"></p>
<h2>总结</h2>

<p><code>[obj callMethodWithCompletionBlock:^&#123; [obj doSomething] &#125;]</code> 这种写法，ARC 会自动负责 block 的内存管理，在上下文开始和结束的地方持有和释放。</p>
<p>block 为开发带来了便利，ARC 又为 block 的内存管理带来了便利，但如果未遵守内存管理的基本原则，仍然会引入内存泄漏的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rob2468.github.io/2018/02/08/callmethodwithcompletionblock-memory-speculating/" data-id="cl4h5hf34000hbdoo7n3z7idc" data-title="callMethodWithCompletionBlock&amp;#58; 中 Block 的内存管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/26/fun-facts-about-raising-a-baby/">养娃趣事</a>
          </li>
        
          <li>
            <a href="/2021/07/31/open-yale-courses-death/">耶鲁大学公开课:死亡-读后感</a>
          </li>
        
          <li>
            <a href="/2021/07/11/jing-imagination/">儿子的想象力</a>
          </li>
        
          <li>
            <a href="/2021/01/09/different-problems/">简单问题、复杂问题、混沌问题</a>
          </li>
        
          <li>
            <a href="/2020/12/27/read-with-my-son/">与儿子一起的睡前阅读</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 陈军<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>