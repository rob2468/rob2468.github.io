---
layout: post
title: 排序，伪代码实现
page_id: id-2018-09-17
---

<h1 class="title">{{ page.title }}</h1>

<h2 id="section_1">一、插入排序</h2>

<h3 id="section_1_1">1. 直接插入排序</h3>

<div class="code"><pre><code>/**
 *  使用插入排序算法，将目标数组从小到大排列
 *  @param array  待排序的目标数组
 *  @param n  数组长度
 */
void InsertSort(int array[], int n) {
    int i, j;
    int tmp;
    for (i = 1; i < n; i++) {
        // 遍历待排序元素
        tmp = array[i];
        for (j = i - 1; j >= 0 && array[j] > tmp; j--) {
            // 遍历已排序元素
            array[j + 1] = array[j];
        }
        array[j + 1] = tmp;
    }
}
</code></pre></div>

时间复杂度 O(n^2)，空间复杂度 O(1)。直接插入排序是稳定的排序算法。

<h3 id="section_1_2">2. 希尔排序</h3>

<h2 id="section_2">二、交换排序</h2>

<h3 id="section_2_1">1. 冒泡排序</h3>

<div class="code"><pre><code>/**
 *  使用冒泡排序算法，将目标数组从小到大排列
 *  @param array  待排序的目标数组
 *  @param n  数组长度
 */
void BubbleSort(int array[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool flag = false;     // 本趟冒泡是否发生交换的标志
        for (int j = n - 1; j > i; j--) {
            if (array[j - 1] > array[j]) {
                // 交换
                int tmp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = tmp;

                flag = true;
             }
         }
         if (!flag) {
             // 本趟遍历没有发生交换，说明已有序
             break;
         }
     }
 }
</code></pre></div>

时间复杂度 O(n^2)，空间复杂度 O(1)。冒泡排序是稳定的排序算法。

<h3 id="section_2_2">2. 快速排序</h3>

<div class="code"><pre><code>/**
 *  使用快速排序算法，将目标数组从小到大排列
 *  @param array  待排序的目标数组
 *  @param low  起始下标
 *  @param high  结束下标
 */
void QuickSort(int array[], int low, int high) {
    if (low < high) {
        int pivotPos = Partition(array, low, high); // 划分
        QuickSort(array, low, pivotPos - 1);
        QuickSort(array, pivotPos + 1, high);
    }
}
/**
 *  将数组划分成两个部分
 *  @param array  待排序的目标数组
 *  @param low  起始下标
 *  @param high  结束下标
 *  @return  已在最终位置元素的下标
 */
int Partition(int array[], int low, int high) {
    int pivot = array[low];             // 将第一个元素设为枢轴值，对表进行划分
    while (low < high) {
        while (low < high && array[high] >= pivot) {
            --high;
        }
        array[low] = array[high];       // 将比枢轴值小的元素移动到左端
        while (low < high && array[low] <= pivot) {
            ++low;
        }
        array[high] = array[low];       // 将比枢轴值大的元素移动到右端
    }
    array[low] = pivot;                 // 枢轴值存放到最终位置
    return low;
}
</code></pre></div>

时间复杂度 O(nlogn)，空间复杂度 O(logn)。快速排序是不稳定的排序算法。

<h2 id="section_3">三、选择排序</h2>

<h3 id="section_3_1">1. 简单选择排序</h3>

<h3 id="section_3_2">2. 堆排序</h3>

堆的定义如下：n 个关键字序列 L[1...n] 称为堆，当且仅当该序列满足：

(1) L(i) <= L(2i) 且 L(i) <= L(2i + 1) 或 (2) L(i) >= L(2i) 且 L(i) >= L(2i + 1)

（1 <= i <= n/2）

满足第(1)种情况的堆称为小根堆（小顶堆），满足第(2)种情况的堆称为大根堆（大顶堆）。

下面代码都是构造和维护大根堆。

<div class="code"><pre><code>/**
 *  使用堆排序算法，将目标数组从小到大排列
 */
void HeapSort(int A[], int len) {
    BuildMaxHeap(A, len);       // 初始建堆
    for (i = len; i > 1; i--) {
        // n - 1 趟的交换和建堆过程
        // 输出堆顶元素（和堆底元素交换）
        int tmp = A[i];
        A[i] = A[1];
        A[1] = tmp;

        // 整理，把剩余的 i - 1 个元素整理成堆
        AdjustDown(A, 1, i - 1);
    } // for
}
/**
 *  建立大根堆，注意 A[0] 中不存储元素，实际存储从 A[1] 开始
 */
void BuildMaxHeap(int A[], int len) {
    for (int i = len/2; i > 0; i--) {   // 从 len/2 ~ 1，反复调整堆
        AdjustDown(A, i, len);
    }
}
/**
 *  将元素 k 向下进行调整
 */
void AdjustDown(int A[], int k, int len) {
    A[0] = A[k];            // A[0] 暂存
    for (i = 2 * k; i <= len; i*= 2) {
        // 沿 key 较大的子结点向下筛选
        if (i < len && A[i] < A[i + 1]) {
            // 取 key 较大的子结点的下标
            i++;
        }
        if (A[0] >= A[i]) {
            // 筛选结束
            break;
        } else {
            A[k] = A[i];    // 将 A[i] 调整到双亲结点上
            k = i;          // 修改 k 值，以便继续向下筛选
        }
    } // for
    A[k] = A[0];            // 被筛选结点的值放入最终位置
}
</code></pre></div>

<div class="code"><pre><code>/**
 *  参数 k 为向上调整的结点，也为堆的元素个数
 */
void AdjustUp(int A[], int k) {
    A[0] = A[k];
    int i = k / 2;  // 若结点值大于双亲结点，则将双亲结点向下调，并继续向上比较
    while (i > 0 && A[i] < A[0]) {
        A[k] = A[i];
        k = i;
        i = k / 2;
    } // while
    A[k] = A[0];
}
</code></pre></div>

注意：堆最重要的操作就是函数 AdjustDown 和 AdjustUp，其余操作均通过这两个操作完成。

时间复杂度 O(nlogn)，空间复杂度 O(1)。堆排序是不稳定的排序算法。

<h2 id="section_4">四、归并排序</h2>

<h3 id="section_4_1">1. 二路归并排序</h3>

<h3 id="section_4_2">2. 多路归并排序</h3>

<h3>参考文献：</h3>

王道论坛. 程序员求职宝典. 电子工业出版社.
