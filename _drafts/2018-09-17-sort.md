---
layout: post
title: 排序，伪代码实现
page_id: id-2018-09-17
---

<h1 class="title">{{ page.title }}</h1>

<h2 id="section_1">一、插入排序</h2>

<h3 id="section_1_1">1. 直接插入排序</h3>

<div class="code"><pre><code>/**
 *  使用插入排序算法，将目标数组从小到大排列
 *  @param array  待排序的目标数组
 *  @param n  数组长度
 */
void InsertSort(int array[], int n) {
    int i, j;
    int tmp;
    for (i = 1; i < n; i++) {
        // 遍历待排序元素
        tmp = array[i];
        for (j = i - 1; j >= 0 && array[j] > tmp; j--) {
            // 遍历已排序元素
            array[j + 1] = array[j];
        }
        array[j + 1] = tmp;
    }
}
</code></pre></div>

时间复杂度 O(n^2)，空间复杂度 O(1)。直接插入排序是稳定的排序算法。

<h3 id="section_1_2">2. 希尔排序</h3>

<h2 id="section_2">二、交换排序</h2>

<h3 id="section_2_1">1. 冒泡排序</h3>

<div class="code"><pre><code>/**
 *  使用冒泡排序算法，将目标数组从小到大排列
 *  @param array  待排序的目标数组
 *  @param n  数组长度
 */
void BubbleSort(int array[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool flag = false;     // 本趟冒泡是否发生交换的标志
        for (int j = n - 1; j > i; j--) {
            if (array[j - 1] > array[j]) {
                // 交换
                int tmp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = tmp;

                flag = true;
             }
         }
         if (!flag) {
             // 本趟遍历没有发生交换，说明已有序
             break;
         }
     }
 }
</code></pre></div>

时间复杂度 O(n^2)，空间复杂度 O(1)。冒泡排序是稳定的排序算法。

<h3 id="section_2_2">2. 快速排序</h3>

<div class="code"><pre><code>/**
 *  使用快速排序算法，将目标数组从小到大排列
 *  @param array  待排序的目标数组
 *  @param low  起始下标
 *  @param high  结束下标
 */
void QuickSort(int array[], int low, int high) {
    if (low < high) {
        int pivotPos = Partition(array, low, high); // 划分
        QuickSort(array, low, pivotPos - 1);
        QuickSort(array, pivotPos + 1, high);
    }
}
/**
 *  将数组划分成两个部分
 *  @param array  待排序的目标数组
 *  @param low  起始下标
 *  @param high  结束下标
 *  @return  已在最终位置元素的下标
 */
int Partition(int array[], int low, int high) {
    int pivot = array[low];             // 将第一个元素设为枢轴值，对表进行划分
    while (low < high) {
        while (low < high && array[high] >= pivot) {
            --high;
        }
        array[low] = array[high];       // 将比枢轴值小的元素移动到左端
        while (low < high && array[low] <= pivot) {
            ++low;
        }
        array[high] = array[low];       // 将比枢轴值大的元素移动到右端
    }
    array[low] = pivot;                 // 枢轴值存放到最终位置
    return low;
}
</code></pre></div>

时间复杂度 O(nlogn)，空间复杂度 O(logn)。快速排序是不稳定的排序算法。

<h2 id="section_3">三、选择排序</h2>

<h3 id="section_3_1">1. 简单选择排序</h3>

<h3 id="section_3_2">2. 堆排序</h3>

<h2 id="section_4">四、归并排序</h2>

<h3 id="section_4_1">1. 二路归并排序</h3>

<h3 id="section_4_2">2. 多路归并排序</h3>

<h3>参考文献：</h3>

王道论坛. 程序员求职宝典. 电子工业出版社.
